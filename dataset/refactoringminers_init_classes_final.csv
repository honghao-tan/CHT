refminer_id,response_content,refactoring_type,prompt,ref_type_in_refminer,file,commit_url
1136760,"class BackgroundCompactionTask implements Runnable
{
	private final ColumnFamilyStore cfs;

	BackgroundCompactionTask(ColumnFamilyStore cfs)
	{
		this.cfs = cfs;
	}

	public void run()
	{
		try
		{
			logger.debug(""Checking {}.{}"", cfs.keyspace.getName(), cfs.name);
			if (!cfs.isValid())
			{
				logger.debug(""Aborting compaction for dropped CF"");
				return;
			}

			AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
			AbstractCompactionTask task = strategy.getNextBackgroundTask(getDefaultGcBefore(cfs));
			if (task == null)
			{
				logger.debug(""No tasks available"");
				return;
			}
			task.execute(metrics);
		}
		finally
		{
			compactingCF.remove(cfs);
		}
		submitBackground(cfs);
	}
}

private static interface AllSSTablesOperation
{
	public void perform(ColumnFamilyStore store, Iterable<SSTableReader> sstables) throws IOException;
}

private void performAllSSTableOperation(final ColumnFamilyStore cfs, final AllSSTablesOperation operation) throws InterruptedException, ExecutionException
{
	final Iterable<SSTableReader> sstables = cfs.markAllCompacting();
	if (sstables == null)
		return;

	Callable<Object> runnable = new Callable<Object>()
	{
		public Object call() throws IOException
		{
			try
			{
				operation.perform(cfs, sstables);
			}
			finally
			{
				cfs.getDataTracker().unmarkCompacting(sstables);
			}
			return this;
		}
	};
	executor.submit(runnable).get();
}

public void performScrub(ColumnFamilyStore cfStore, final boolean skipCorrupted, final boolean checkData) throws InterruptedException, ExecutionException
{
	performAllSSTableOperation(cfStore, new AllSSTablesOperation()
	{
		public void perform(ColumnFamilyStore store, Iterable<SSTableReader> sstables) throws IOException
		{
			doScrub(store, sstables, skipCorrupted, checkData);
		}
	});
}

public void performSSTableRewrite(ColumnFamilyStore cfStore, final boolean excludeCurrentVersion) throws InterruptedException, ExecutionException
{
	performAllSSTableOperation(cfStore, new AllSSTablesOperation()
	{
		public void perform(ColumnFamilyStore cfs, Iterable<SSTableReader> sstables)
		{
			for (final SSTableReader sstable : sstables)
			{
				if (excludeCurrentVersion && sstable.descriptor.version.equals(Descriptor.Version.CURRENT))
					continue;

				// SSTables are marked by the caller
				// NOTE: it is important that the task create one and only one sstable, even for Leveled compaction (see LeveledManifest.replace())
				AbstractCompactionTask task = cfs.getCompactionStrategy().getCompactionTask(Collections.singleton(sstable), NO_GC, Long.MAX_VALUE);
				task.setUserDefined(true);
				task.setCompactionType(OperationType.UPGRADE_SSTABLES);
				task.execute(metrics);
			}
		}
	});
}

public void performCleanup(ColumnFamilyStore cfStore, final CounterId.OneShotRenewer renewer) throws InterruptedException, ExecutionException
{
	performAllSSTableOperation(cfStore, new AllSSTablesOperation()
	{
		public void perform(ColumnFamilyStore store, Iterable<SSTableReader> sstables) throws IOException
		{
			// Sort the column families in order of SSTable size, so cleanup of smaller CFs
			// can free up space for larger ones
			List<SSTableReader> sortedSSTables = Lists.newArrayList(sstables);
			Collections.sort(sortedSSTables, new SSTableReader.SizeComparator());

			doCleanupCompaction(store, sortedSSTables, renewer);
		}
	});
}

public void performMaximal(final ColumnFamilyStore cfStore) throws InterruptedException, ExecutionException
{
	submitMaximal(cfStore, getDefaultGcBefore(cfStore)).get();
}

public Future<?> submitMaximal(final ColumnFamilyStore cfStore, final int gcBefore)
{
	// here we compute the task off the compaction executor, so having that present doesn't
	// confuse runWithCompactionsDisabled -- i.e., we don't want to deadlock ourselves, waiting
	// for ourselves to finish/acknowledge cancellation before continuing.
	final AbstractCompactionTask task = cfStore.getCompactionStrategy().getMaximalTask(gcBefore);
	Runnable runnable = new WrappedRunnable()
	{
		protected void runMayThrow() throws IOException
		{
			if (task == null)
				return;
			task.execute(metrics);
		}
	};
	return executor.submit(runnable);
}

public void forceUserDefinedCompaction(String dataFiles)
{
	String[] filenames = dataFiles.split("","");
	Multimap<Pair<String, String>, Descriptor> descriptors = ArrayListMultimap.create();

	for (String filename : filenames)
	{
		// extract keyspace and columnfamily name from filename
		Descriptor desc = Descriptor.fromFilename(filename.trim());
		if (Schema.instance.getCFMetaData(desc) == null)
		{
			logger.warn(""Schema does not exist for file {}. Skipping."", filename);
			continue;
		}
		File directory = new File(desc.ksname + File.separator + desc.cfname);
		// group by keyspace/columnfamily
		Pair<Descriptor, String> p = Descriptor.fromFilename(directory, filename.trim());
		Pair<String, String> key = Pair.create(p.left.ksname, p.left.cfname);
		descriptors.put(key, p.left);
	}

	List<Future<?>> futures = new ArrayList<>();
	for (Pair<String, String> key : descriptors.keySet())
	{
		ColumnFamilyStore cfs = Keyspace.open(key.left).getColumnFamilyStore(key.right);
		futures.add(submitUserDefined(cfs, descriptors.get(key), getDefaultGcBefore(cfs)));
	}
	FBUtilities.waitOnFutures(futures);
}

public Future<?> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
{
	Runnable runnable = new WrappedRunnable()
	{
		protected void runMayThrow() throws IOException
		{
			// look up the sstables now that we're on the compaction executor, so we don't try to re-compact
			// something that was already being compacted earlier.
			Collection<SSTableReader> sstables = new ArrayList<SSTableReader>(dataFiles.size());
			for (Descriptor desc : dataFiles)
			{
				// inefficient but not in a performance sensitive path
				SSTableReader sstable = lookupSSTable(cfs, desc);
				if (sstable == null)
				{
					logger.info(""Will not compact {}: it is not an active sstable"", desc);
				}
				else
				{
					sstables.add(sstable);
				}
			}

			if (sstables.isEmpty())
			{
				logger.info(""No files to compact for user defined compaction"");
			}
			else
			{
				AbstractCompactionTask task = cfs.getCompactionStrategy().getUserDefinedTask(sstables, gcBefore);
				if (task != null)
					task.execute(metrics);
			}
		}
	};
	return executor.submit(runnable);
}

// This acquire a reference on the sstable
// This is not efficent, do not use in any critical path
private SSTableReader lookupSSTable(final ColumnFamilyStore cfs, Descriptor descriptor)
{
	for (SSTableReader sstable : cfs.getSSTables())
	{
		// .equals() with no other changes won't work because in sstable.descriptor, the directory is an absolute path.
		// We could construct descriptor with an absolute path too but I haven't found any satisfying way to do that
		// (DB.getDataFileLocationForTable() may not return the right path if you have multiple volumes). Hence the
		// endsWith.
		if (sstable.descriptor.toString().endsWith(descriptor.toString()))
			return sstable;
	}
	return null;
}",rename class,"Rename the class ""BackgroundCompactionTask"" to [keyword]:",TRUE,src/java/org/apache/cassandra/db/compaction/CompactionManager.java,https://github.com/apache/cassandra/commit/f283ed29814403bde6350a2598cdd6e2c8b983d5
1123715,"public class FilterResourcesStep implements Step {

  private static final Pattern DRAWABLE_PATH_PATTERN = Pattern.compile(
      "".*drawable.*/.*(png|jpg|jpeg|gif|webp)"", Pattern.CASE_INSENSITIVE);
  // Android doesn't scale these, so we don't need to scale or filter them either.
  private static final Pattern DRAWABLE_EXCLUDE_PATTERN = Pattern.compile(
      "".*-nodpi.*"", Pattern.CASE_INSENSITIVE);

  private static final Logger LOG = Logger.get(FilterResourcesStep.class);

  @VisibleForTesting
  static final Pattern NON_ENGLISH_STRINGS_FILE_PATH = Pattern.compile(
      ""(\\b|.*/)res/values-.+/strings.xml"", Pattern.CASE_INSENSITIVE);

  @VisibleForTesting
  static final Pattern VALUES_DIR_PATTERN = Pattern.compile(
      ""\\b|.*/res/values-([a-z]{2})(?:-r([A-Z]{2}))*/.*"");

  private final ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
  private final boolean filterDrawables;
  private final boolean filterStrings;
  private final ImmutableSet<Path> whitelistedStringDirs;
  private final ImmutableSet<String> locales;
  private final FilteredDirectoryCopier filteredDirectoryCopier;
  @Nullable
  private final Set<Filters.Density> targetDensities;
  @Nullable
  private final DrawableFinder drawableFinder;
  @Nullable
  private final ImageScaler imageScaler;

  /**
   * Creates a command that filters a specified set of directories.
   * @param inResDirToOutResDirMap set of {@code res} directories to filter
   * @param filterDrawables whether to filter drawables (images)
   * @param filterStrings whether to filter non-english strings
   * @param whitelistedStringDirs set of directories containing string resource files that must not
   *     be filtered out.
   * @param filteredDirectoryCopier refer {@link FilteredDirectoryCopier}
   * @param targetDensities densities we're interested in keeping (e.g. {@code mdpi}, {@code hdpi}
   *     etc.) Only applicable if filterDrawables is true
   * @param drawableFinder refer {@link DrawableFinder}. Only applicable if filterDrawables is true.
   * @param imageScaler if not null, use the {@link ImageScaler} to downscale higher-density
   *     drawables for which we weren't able to find an image file of the proper density (as opposed
   *     to allowing Android to do it at runtime). Only applicable if filterDrawables. is true.
   */
  @VisibleForTesting
  FilterResourcesStep(
      ImmutableBiMap<Path, Path> inResDirToOutResDirMap,
      boolean filterDrawables,
      boolean filterStrings,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      FilteredDirectoryCopier filteredDirectoryCopier,
      @Nullable Set<Filters.Density> targetDensities,
      @Nullable DrawableFinder drawableFinder,
      @Nullable ImageScaler imageScaler) {

    Preconditions.checkArgument(filterDrawables || filterStrings || !locales.isEmpty());
    Preconditions.checkArgument(!filterDrawables ||
        (targetDensities != null && drawableFinder != null));
    this.inResDirToOutResDirMap = inResDirToOutResDirMap;
    this.filterDrawables = filterDrawables;
    this.filterStrings = filterStrings;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.filteredDirectoryCopier = filteredDirectoryCopier;
    this.targetDensities = targetDensities;
    this.drawableFinder = drawableFinder;
    this.imageScaler = imageScaler;
    LOG.info(
        ""FilterResourcesStep: filterDrawables: %s; filterStrings: %s"",
        filterDrawables,
        filterStrings);
  }

  @Override
  public int execute(ExecutionContext context) {
    try {
      return doExecute(context);
    } catch (Exception e) {
      context.logError(e, ""There was an error filtering resources."");
      return 1;
    }
  }

  private int doExecute(ExecutionContext context) throws IOException, InterruptedException {
    List<Predicate<Path>> pathPredicates = Lists.newArrayList();

    boolean canDownscale = imageScaler != null && imageScaler.isAvailable(context);
    LOG.info(
        ""FilterResourcesStep: canDownscale: %s. imageScalar non-null: %s."",
        canDownscale,
        imageScaler != null);

    if (filterDrawables) {
      Preconditions.checkNotNull(drawableFinder);
      Set<Path> drawables = drawableFinder.findDrawables(
          inResDirToOutResDirMap.keySet(),
          context.getProjectFilesystem());
      pathPredicates.add(
          Filters.createImageDensityFilter(
              drawables,
              Preconditions.checkNotNull(targetDensities),
              canDownscale));
    }

    if (!locales.isEmpty()) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path input) {
              Matcher matcher = VALUES_DIR_PATTERN.matcher(MorePaths.pathWithUnixSeparators(input));
              if (!matcher.matches() || isPathWhitelisted(input)) {
                return true;
              }
              String locale = matcher.group(1);
              if (matcher.group(2) != null) {
                locale += ""_"" + matcher.group(2);
              }
              return locales.contains(locale);
            }
          });
    }

    if (filterStrings) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path pathRelativeToProjectRoot) {
              if (!NON_ENGLISH_STRINGS_FILE_PATH.matcher(MorePaths.pathWithUnixSeparators(
                      pathRelativeToProjectRoot))
                  .matches()) {
                return true;
              }

              return isPathWhitelisted(pathRelativeToProjectRoot);
            }
          });
    }

    // Create filtered copies of all resource directories. These will be passed to aapt instead.
    filteredDirectoryCopier.copyDirs(
        context.getProjectFilesystem(),
        inResDirToOutResDirMap,
        Predicates.and(pathPredicates));

    // If an ImageScaler was specified, but only if it is available, try to apply it.
    if (canDownscale && filterDrawables) {
      scaleUnmatchedDrawables(context);
    }

    return 0;
  }

  private boolean isPathWhitelisted(Path path) {
    for (Path whitelistedStringDir : whitelistedStringDirs) {
      if (path.startsWith(whitelistedStringDir)) {
        return true;
      }
    }

    return false;
  }

  @Override
  public String getShortName() {
    return ""resource_filtering"";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return ""Filtering drawable and string resources."";
  }
}",rename field,"Rename the field ""filterStrings"" to [keyword]:",FALSE,src/com/facebook/buck/android/FilterResourcesStep.java,https://github.com/facebook/buck/commit/d49765899cb9df6781fff9773ffc244b5167351c
1120106,"class MapAnnotationAttributeExtractor extends AbstractAliasAwareAnnotationAttributeExtractor {

        MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,
                        AnnotatedElement annotatedElement) {
                super(annotationType, annotatedElement, new HashMap<String, Object>(attributes));
                validateAttributes(attributes, annotationType);
        }

        @Override
        protected Object getRawAttributeValue(Method attributeMethod) {
                return getMap().get(attributeMethod.getName());
        }

        @Override
        protected Object getRawAttributeValue(String attributeName) {
                return getMap().get(attributeName);
        }

        @SuppressWarnings(""unchecked"")
        private Map<String, Object> getMap() {
                return (Map<String, Object>) getSource();
        }

        private static void validateAttributes(Map<String, Object> attributes, Class<? extends Annotation> annotationType) {
                for (Method attributeMethod : getAttributeMethods(annotationType)) {
                        String attributeName = attributeMethod.getName();

                        Object attributeValue = attributes.get(attributeName);
                        if (attributeValue == null) {
                                throw new IllegalArgumentException(String.format(
                                        ""Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s]."",
                                        attributes, attributeName, annotationType.getName()));
                        }

                        Class<?> returnType = attributeMethod.getReturnType();
                        if (!ClassUtils.isAssignable(returnType, attributeValue.getClass())) {
                                throw new IllegalArgumentException(String.format(
                                        ""Attributes map [%s] returned a value of type [%s] for attribute [%s], ""
                                                        + ""but a value of type [%s] is required as defined by annotation type [%s]."", attributes,
                                        attributeValue.getClass().getName(), attributeName, returnType.getName(), annotationType.getName()));
                        }
                }
        }

}

public abstract class AnnotationUtils {

	/**
	 * The attribute name for annotations with a single element.
	 */
	public static final String VALUE = ""value"";


	/**
	 * An object that can be stored in {@link AnnotationAttributes} as a
	 * placeholder for an attribute's declared default value.
	 */
	private static final Object DEFAULT_VALUE_PLACEHOLDER = new String(""<SPRING DEFAULT VALUE PLACEHOLDER>"");

	private static final Map<AnnotationCacheKey, Annotation> findAnnotationCache =
			new ConcurrentReferenceHashMap<AnnotationCacheKey, Annotation>(256);

	private static final Map<Class<?>, Boolean> annotatedInterfaceCache =
			new ConcurrentReferenceHashMap<Class<?>, Boolean>(256);

	private static final Map<Class<? extends Annotation>, Boolean> synthesizableCache =
			new ConcurrentReferenceHashMap<Class<? extends Annotation>, Boolean>(256);

	private static final Map<Class<? extends Annotation>, Map<String, String>> attributeAliasesCache =
			new ConcurrentReferenceHashMap<Class<? extends Annotation>, Map<String, String>>(256);

	private static final Map<Class<? extends Annotation>, List<Method>> attributeMethodsCache =
			new ConcurrentReferenceHashMap<Class<? extends Annotation>, List<Method>>(256);

	private static transient Log logger;

@SuppressWarnings(""unchecked"")
	public static <A extends Annotation> A getAnnotation(Annotation ann, Class<A> annotationType) {
		if (annotationType.isInstance(ann)) {
			return synthesizeAnnotation((A) ann);
		}
		Class<? extends Annotation> annotatedElement = ann.annotationType();
		try {
			return synthesizeAnnotation(annotatedElement.getAnnotation(annotationType), annotatedElement);
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(annotatedElement, ex);
			return null;
		}
	}

	public static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {
		try {
			A annotation = annotatedElement.getAnnotation(annotationType);
			if (annotation == null) {
				for (Annotation metaAnn : annotatedElement.getAnnotations()) {
					annotation = metaAnn.annotationType().getAnnotation(annotationType);
					if (annotation != null) {
						break;
					}
				}
			}
			return synthesizeAnnotation(annotation, annotatedElement);
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(annotatedElement, ex);
			return null;
		}
	}

	public static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {
		Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);
		return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);
	}

	public static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {
		try {
			return annotatedElement.getAnnotations();
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(annotatedElement, ex);
		}
		return null;
	}

	public static Annotation[] getAnnotations(Method method) {
		try {
			return BridgeMethodResolver.findBridgedMethod(method).getAnnotations();
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(method, ex);
		}
		return null;
	}

	public static <A extends Annotation> Set<A> getRepeatableAnnotation(Method method,
			Class<? extends Annotation> containerAnnotationType, Class<A> annotationType) {

		Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);
		return getRepeatableAnnotation((AnnotatedElement) resolvedMethod, containerAnnotationType, annotationType);
	}

	public static <A extends Annotation> Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,
			Class<? extends Annotation> containerAnnotationType, Class<A> annotationType) {

		try {
			if (annotatedElement.getAnnotations().length > 0) {
				return new AnnotationCollector<A>(containerAnnotationType, annotationType).getResult(annotatedElement);
			}
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(annotatedElement, ex);
		}
		return Collections.emptySet();
	}

	public static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {
		// Do NOT store result in the findAnnotationCache since doing so could break
		// findAnnotation(Class, Class) and findAnnotation(Method, Class).
		return synthesizeAnnotation(findAnnotation(annotatedElement, annotationType, new HashSet<Annotation>()),
			annotatedElement);
	}

	@SuppressWarnings(""unchecked"")
	private static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType, Set<Annotation> visited) {
		Assert.notNull(annotatedElement, ""AnnotatedElement must not be null"");
		try {
			Annotation[] anns = annotatedElement.getDeclaredAnnotations();
			for (Annotation ann : anns) {
				if (ann.annotationType().equals(annotationType)) {
					return (A) ann;
				}
			}
			for (Annotation ann : anns) {
				if (!isInJavaLangAnnotationPackage(ann) && visited.add(ann)) {
					A annotation = findAnnotation((AnnotatedElement) ann.annotationType(), annotationType, visited);
					if (annotation != null) {
						return annotation;
					}
				}
			}
		}
		catch (Exception ex) {
			// Assuming nested Class values not resolvable within annotation attributes...
			handleIntrospectionFailure(annotatedElement, ex);
		}
		return null;
	}
}",rename method,"Rename the method ""validateAttributes"" to [keyword]:",TRUE,spring-core/src/main/java/org/springframework/core/annotation/MapAnnotationAttributeExtractor.java,https://github.com/spring-projects/spring-framework/commit/ece12f9d370108549fffac105e4bcb7faeaaf124
1120722,"public void drawLocations(RotatedTileBox tb, Canvas canvas, double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude) {
	points.clear();
	actionPoints.clear();
	boolean previousVisible = false;
	Location lastProjection = helper.getLastProjection();
	if (lastProjection != null) {
		if (leftLongitude <= lastProjection.getLongitude() && lastProjection.getLongitude() <= rightLongitude
				&& bottomLatitude <= lastProjection.getLatitude() && lastProjection.getLatitude() <= topLatitude) {
			points.add(lastProjection);
			previousVisible = true;
		}
	}
	List<Location> routeNodes = helper.getRoute().getRouteLocations();
	int cd = helper.getRoute().getCurrentRoute();
	List<RouteDirectionInfo> rd = helper.getRouteDirections();
	Iterator<RouteDirectionInfo> it = rd.iterator();
	for (int i = 0; i < routeNodes.size(); i++) {
		Location ls = routeNodes.get(i);
		if (leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()
				&& ls.getLatitude() <= topLatitude) {
			points.add(ls);
			
			if (!previousVisible) {
				if (i > 0) {
					points.add(0, routeNodes.get(i - 1));
				} else if (lastProjection != null) {
					points.add(0, lastProjection);
				}
			}
			previousVisible = true;
		} else if (previousVisible) {
			points.add(ls);
			drawSegment(tb, canvas);
			previousVisible = false;
			points.clear();
		}
	}
	drawSegment(tb, canvas);
	if (tb.getZoom() >= 14) {
		calculateActionPoints(topLatitude, leftLongitude, bottomLatitude, rightLongitude, lastProjection,
				routeNodes, cd, it, tb.getZoom());
		drawAction(tb, canvas);
	}
}


private void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,
		double rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,
		Iterator<RouteDirectionInfo> it, int zoom) {
	RouteDirectionInfo nf = null;
	
	double DISTANCE_ACTION = 35;
	if(zoom >= 17) {
		DISTANCE_ACTION = 15;
	} else if (zoom == 15) {
		DISTANCE_ACTION = 70;
	} else if (zoom < 15) {
		DISTANCE_ACTION = 110;
	}
	double actionDist = 0;
	Location previousAction = null; 
	actionPoints.clear();
	int prevFinishPoint = -2;
	for (int i = 0; i < routeNodes.size(); i++) {
		Location ls = routeNodes.get(i);
		if(nf != null) {
			int pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;
			if(pnt < i + cd ) {
				nf = null;
			}
		}
		while (nf == null && it.hasNext()) {
			nf = it.next();
			int pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;
			if (pnt < i + cd) {
				nf = null;
			}
		}
		boolean action = nf != null && (nf.routePointOffset == i + cd ||
				(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));
		if(!action && previousAction == null) {
			continue;
		}
		boolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()
				&& ls.getLatitude() <= topLatitude;
		if(!action) {
			if(previousAction != null) {
				float dist = ls.distanceTo(previousAction);
				actionDist += dist;
				if(actionDist >= DISTANCE_ACTION) {
					actionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));
					actionPoints.add(null);
					prevFinishPoint = i;
					previousAction = null;
					actionDist = 0;
				} else {
					actionPoints.add(ls);
					previousAction = ls;
				}
			}
		} else {
			// action point
			if(visible) {
				// visible action point
				if (previousAction == null) {
					// put some points in front
					int ind = actionPoints.size();
					Location lprevious = ls;
					double dist = 0;
					for (int k = i - 1; k >= -1; k--) {
						Location l = k == -1 ? lastProjection : routeNodes.get(k);
						float loc = lprevious.distanceTo(l);
						if(prevFinishPoint == k) {
							if(ind >= 2) {
								actionPoints.remove(ind - 2);
								actionPoints.remove(ind - 2);
							}
							prevFinishPoint = -2;
							break;
						}
						dist += loc;
						if (dist >= DISTANCE_ACTION) {
							if(loc > 1) {
								actionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));
							}
							break;
						} else {
							actionPoints.add(ind, l);
							lprevious = l;
						}
						
					}
				}
				actionPoints.add(ls);
				previousAction = ls;
				actionDist = 0;
			}
		}
	}
	if(previousAction != null) {
		actionPoints.add(null);
	}
}

private Location calculateProjection(double part, Location lp, Location l) {
	Location p = new Location(l);
	p.setLatitude(lp.getLatitude() + part * (l.getLatitude() - lp.getLatitude()));
	p.setLongitude(lp.getLongitude() + part * (l.getLongitude() - lp.getLongitude()));
	return p;
}


public RoutingHelper getHelper() {
	return helper;
}


// to show further direction
public Path getPath() {
	return path;
}


@Override
public void destroyLayer() {
	
}
@Override
public boolean drawInScreenPixels() {
	return false;
}

@Override
public boolean onLongPressEvent(PointF point, RotatedTileBox tileBox) {
	return false;
}

@Override
public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
	return false;
}",rename variable,"Rename the variable ""i"" to [keyword]:",TRUE,OsmAnd/src/net/osmand/plus/views/RouteLayer.java,https://github.com/osmandapp/Osmand/commit/c45b9e6615181b7d8f4d7b5b1cc141169081c02c
1153354,"private static void fillGeneralInformation(Swagger swagger, Definition definition,
        List<String> produces, List<String> consumes) {

    Info info = swagger.getInfo();

    // Contact
    if (info.getContact() != null) {
        org.restlet.ext.apispark.internal.model.Contact contact = new org.restlet.ext.apispark.internal.model.Contact();
        contact.setEmail(info.getContact().getEmail());
        contact.setName(info.getContact().getName());
        contact.setUrl(info.getContact().getUrl());
        definition.setContact(contact);
    }

    if (info.getLicense() != null) {
        // License
        org.restlet.ext.apispark.internal.model.License license = new org.restlet.ext.apispark.internal.model.License();
        license.setName(info.getLicense().getName());
        license.setUrl(info.getLicense().getUrl());
        definition.setLicense(license);
    }

    // Contract
    Contract contract = new Contract();
    contract.setDescription(info.getDescription());
    contract.setName(info.getTitle());
    definition.setContract(contract);

    // Media types
    if (swagger.getProduces() != null) {
        produces.addAll(swagger.getProduces());
    }
    if (swagger.getConsumes() != null) {
        consumes.addAll(swagger.getConsumes());
    }

    // General
    definition.setVersion(info.getVersion());
    definition.setTermsOfService(info.getTermsOfService());
    // TODO: attribution and keywords not implemented in Swagger 2.0
    definition.setAttribution(null);
}

private static void fillHeader(Header header, HeaderParameter swaggerHeader) {
    header.setName(swaggerHeader.getName());
    header.setRequired(swaggerHeader.getRequired());
    header.setDescription(swaggerHeader.getDescription());
    header.setAllowMultiple(true);
    header.setDefaultValue(swaggerHeader.getDefaultValue());
    // TODO: example not implemented in Swagger 2.0

    SwaggerTypeFormat swaggerTypeFormat = new SwaggerTypeFormat(
            swaggerHeader.getType(),
            swaggerHeader.getFormat(),
            swaggerHeader.getItems());
    header.setType(SwaggerTypes.toDefinitionPrimitiveType(swaggerTypeFormat));
}

private static void fillOperation(Operation swaggerOperation, Resource resource,
        Contract contract, String methodName,
        List<String> produces, List<String> consumes,
        Map<String, Object> parameters) {
    if (swaggerOperation == null) {
        return;
    }

    org.restlet.ext.apispark.internal.model.Operation operation =
            new org.restlet.ext.apispark.internal.model.Operation();

    operation.addProduces(produces);
    operation.addProduces(swaggerOperation.getProduces());

    operation.addConsumes(consumes);
    operation.addConsumes(swaggerOperation.getConsumes());

    operation.setDescription(swaggerOperation.getDescription());
    operation.setMethod(methodName);
    operation.setName(swaggerOperation.getOperationId());

    fillParameters(swaggerOperation, operation, resource, parameters);
    fillResponses(swaggerOperation, operation, contract, parameters);
    fillInputPayload(swaggerOperation, operation, contract);

    resource.getOperations().add(operation);
}

private static void fillOperations(Path path, Resource resource,
        Contract contract, List<String> produces, List<String> consumes,
        Map<String, Object> parameters) {

    fillOperation(path.getGet(), resource, contract, Method.GET.getName(),
            produces, consumes, parameters);
    fillOperation(path.getPost(), resource, contract, Method.POST.getName(),
            produces, consumes, parameters);
    fillOperation(path.getPut(), resource, contract, Method.PUT.getName(),
            produces, consumes, parameters);
    fillOperation(path.getDelete(), resource, contract, Method.DELETE.getName(),
            produces, consumes, parameters);
    fillOperation(path.getOptions(), resource, contract, Method.OPTIONS.getName(),
            produces, consumes, parameters);
    fillOperation(path.getPatch(), resource, contract, Method.PATCH.getName(),
            produces, consumes, parameters);
}

private static void fillParameters(Operation swaggerOperation,
        org.restlet.ext.apispark.internal.model.Operation operation, Resource resource,
        Map<String, Object> parameters) {
    if (swaggerOperation.getParameters() == null) {
        return;
    }

    for (Parameter swaggerParameter : swaggerOperation.getParameters()) {

        if (swaggerParameter instanceof RefParameter) {
            RefParameter refParameter = (RefParameter) swaggerParameter;
            Object rwadefParameter = parameters.get(refParameter.getSimpleRef());

            if (rwadefParameter == null) {
                LOGGER.warning(""The parameter "" + refParameter.getName()
                        + "" was not found in the list of declared parameters."");
            } else if (rwadefParameter instanceof Header) {
                operation.getHeaders().add((Header) rwadefParameter);
            } else if (rwadefParameter instanceof PathVariable) {
                resource.addPathVariable((PathVariable) rwadefParameter);

            } else if (rwadefParameter instanceof org.restlet.ext.apispark.internal.model.QueryParameter) {
                operation.getQueryParameters().add(
                        (org.restlet.ext.apispark.internal.model.QueryParameter) rwadefParameter);

            } else if (rwadefParameter instanceof PayLoad) {
                operation.setInputPayLoad((PayLoad) rwadefParameter);

            } else {
                LOGGER.warning(""The type of declared parameter "" + refParameter.getName() + "", "" +
                        rwadefParameter.getClass() + "" is not supported."");
            }

        } else if (swaggerParameter instanceof QueryParameter) {
            org.restlet.ext.apispark.internal.model.QueryParameter queryParameter =
                    new org.restlet.ext.apispark.internal.model.QueryParameter();
            QueryParameter swaggerQueryParameter = (QueryParameter) swaggerParameter;

            fillQueryParameter(queryParameter, swaggerQueryParameter);
            operation.getQueryParameters().add(queryParameter);
        } else if (swaggerParameter instanceof PathParameter) {
            org.restlet.ext.apispark.internal.model.PathVariable pathVariable =
                    new org.restlet.ext.apispark.internal.model.PathVariable();
            PathParameter swaggerPathVariable = (PathParameter) swaggerParameter;

            fillPathVariable(pathVariable, swaggerPathVariable);
            if (resource.getPathVariable(pathVariable.getName()) == null) {
                resource.getPathVariables().add(pathVariable);
            }
        } else if (swaggerParameter instanceof HeaderParameter) {
            Header header = new Header();
            HeaderParameter swaggerHeader = new HeaderParameter();

            fillHeader(header, swaggerHeader);
            operation.getHeaders().add(header);
        } else {
            if (!(swaggerParameter instanceof BodyParameter)) {
                LOGGER.warning(""Unsupported parameter type for "" + swaggerParameter.getName() +
                        "" of type "" + swaggerParameter.getClass().getName());
            }
        }
    }
}",change method signature,"Add a new parameter to the ""fillGeneralInformation"" method and name it [keyword]:",FALSE,modules/org.restlet.ext.apispark/src/org/restlet/ext/apispark/internal/conversion/swagger/v2_0/Swagger2Reader.java,https://github.com/restlet/restlet-framework-java/commit/7ffe37983e2f09637b0c84d526a2f824de652de4
1153146,"public void emit(C context, ObjExpr objx, GeneratorAdapter gen){
    objx.emitVar(gen, var);

    if (shadowsCoreMapping)
    {
        gen.dup();
        gen.getField(VAR_TYPE, ""ns"", NS_TYPE);
        gen.swap();
        gen.dup();
        gen.getField(VAR_TYPE, ""sym"", SYMBOL_TYPE);
        gen.swap();
        gen.invokeVirtual(NS_TYPE, internVar);
    }

    if(isDynamic)
        {
        gen.push(isDynamic);
        gen.invokeVirtual(VAR_TYPE, setDynamicMethod);
        }
    if(meta != null)
        {
        if (initProvided || true)//includesExplicitMetadata((MapExpr) meta))
            {
            gen.dup();
            meta.emit(C.EXPRESSION, objx, gen);
            gen.checkCast(IPERSISTENTMAP_TYPE);
            gen.invokeVirtual(VAR_TYPE, setMetaMethod);
            }
        }
    if(initProvided)
        {
        gen.dup();
        if(init instanceof FnExpr)
            {
            ((FnExpr)init).emitForDefn(objx, gen);
            }
        else
            init.emit(C.EXPRESSION, objx, gen);
        gen.invokeVirtual(VAR_TYPE, bindRootMethod);
        }

    if(context == C.STATEMENT)
        gen.pop();
}

public boolean hasJavaClass(){
    return true;
}

public Class getJavaClass(){
    return Var.class;
}

static class Parser implements IParser{
    public Expr parse(C context, Object form) {
        //(def x) or (def x initexpr) or (def x ""docstring"" initexpr)
        String docstring = null;
        if(RT.count(form) == 4 && (RT.third(form) instanceof String)) {
            docstring = (String) RT.third(form);
            form = RT.list(RT.first(form), RT.second(form), RT.fourth(form));
        }
        if(RT.count(form) > 3)
            throw Util.runtimeException(""Too many arguments to def"");
        else if(RT.count(form) < 2)
            throw Util.runtimeException(""Too few arguments to def"");
        else if(!(RT.second(form) instanceof Symbol))
                throw Util.runtimeException(""First argument to def must be a Symbol"");
        Symbol sym = (Symbol) RT.second(form);
        Var v = lookupVar(sym, true);
        if(v == null)
            throw Util.runtimeException(""Can't refer to qualified var that doesn't exist"");
        boolean shadowsCoreMapping = false;
        if(!v.ns.equals(currentNS()))
            {
            if(sym.ns == null)
                {
                v = currentNS().intern(sym);
                shadowsCoreMapping = true;
                registerVar(v);
                }
//					throw Util.runtimeException(""Name conflict, can't def "" + sym + "" because namespace: "" + currentNS().name +
//					                    "" refers to:"" + v);
            else
                throw Util.runtimeException(""Can't create defs outside of current ns"");
            }
        IPersistentMap mm = sym.meta();
        boolean isDynamic = RT.booleanCast(RT.get(mm,dynamicKey));
        if(isDynamic)
            v.setDynamic();
        if(!isDynamic && sym.name.startsWith(""*"") && sym.name.endsWith(""*"") && sym.name.length() > 2)
            {
            RT.errPrintWriter().format(""Warning: %1$s not declared dynamic and thus is not dynamically rebindable, ""
                                        +""but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n"",
                                        sym, SOURCE_PATH.get(), LINE.get());
            }
        if(RT.booleanCast(RT.get(mm, arglistsKey)))
            {
            IPersistentMap vm = v.meta();
            //vm = (IPersistentMap) RT.assoc(vm,staticKey,RT.T);
            //drop quote
            vm = (IPersistentMap) RT.assoc(vm,arglistsKey,RT.second(mm.valAt(arglistsKey)));
            v.setMeta(vm);
            }
        Object source_path = SOURCE_PATH.get();
        source_path = source_path == null ? ""NO_SOURCE_FILE"" : source_path;
        mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path);
        if (docstring != null)
            mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring);
//			mm = mm.without(RT.DOC_KEY)
//					.without(Keyword.intern(null, ""arglists""))
//					.without(RT.FILE_KEY)
//					.without(RT.LINE_KEY)
//					.without(RT.COLUMN_KEY)
//					.without(Keyword.intern(null, ""ns""))
//					.without(Keyword.intern(null, ""name""))
//					.without(Keyword.intern(null, ""added""))
//					.without(Keyword.intern(null, ""static""));
        mm = (IPersistentMap) elideMeta(mm);
        Expr meta = mm.count()==0 ? null:analyze(context == C.EVAL ? context : C.EXPRESSION, mm);
        return new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(),
                            v, analyze(context == C.EVAL ? context : C.EXPRESSION, RT.third(form), v.sym.name),
                            meta, RT.count(form) == 3, isDynamic, shadowsCoreMapping);
    }
}
}

public static class AssignExpr implements Expr{
public final AssignableExpr target;
public final Expr val;

public AssignExpr(AssignableExpr target, Expr val){
    this.target = target;
    this.val = val;
}

public Object eval() {
    return target.evalAssign(val);
}

public void emit(C context, ObjExpr objx, GeneratorAdapter gen){
    target.emitAssign(context, objx, gen, val);
}

public boolean hasJavaClass() {
    return val.hasJavaClass();
}

public Class getJavaClass() {
    return val.getJavaClass();
}

static class Parser implements IParser{
    public Expr parse(C context, Object frm) {
        ISeq form = (ISeq) frm;
        if(RT.length(form) != 3)
            throw new IllegalArgumentException(""Malformed assignment, expecting (set! target val)"");
        Expr target = analyze(C.EXPRESSION, RT.second(form));
        if(!(target instanceof AssignableExpr))
            throw new IllegalArgumentException(""Invalid assignment target"");
        return new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form)));
    }
}
}

public static class VarExpr implements Expr, AssignableExpr{
public final Var var;
public final Object tag;
final static Method getMethod = Method.getMethod(""Object get()"");
final static Method setMethod = Method.getMethod(""Object set(Object)"");

public VarExpr(Var var, Symbol tag){
    this.var = var;
    this.tag = tag != null ? tag : var.getTag();
}

public Object eval() {
    return var.deref();
}

public void emit(C context, ObjExpr objx, GeneratorAdapter gen){
    objx.emitVarValue(gen,var);
    if(context == C.STATEMENT)
        {
        gen.pop();
        }
}

public boolean hasJavaClass(){
    return tag != null;
}

public Class getJavaClass() {
    return HostExpr.tagToClass(tag);
}

public Object evalAssign(Expr val) {
    return var.set(val.eval());
}

public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen,
                        Expr val){
    objx.emitVar(gen, var);
    val.emit(C.EXPRESSION, objx, gen);
    gen.invokeVirtual(VAR_TYPE, setMethod);
    if(context == C.STATEMENT)
        gen.pop();
}
}
",Introduce Parameter Object,Introduce a new Parameter Object and name it [keyword]:,FALSE,src/jvm/clojure/lang/Compiler.java,https://github.com/clojure/clojure/commit/309c03055b06525c275b278542c881019424760e
1150188,"private MessagingService(boolean testOnly)
{
    for (Verb verb : DROPPABLE_VERBS)
        droppedMessagesMap.put(verb, new DroppedMessages(verb));

    listenGate = new SimpleCondition();
    verbHandlers = new EnumMap<>(Verb.class);

    if (!testOnly)
    {
        Runnable logDropped = new Runnable()
        {
            public void run()
            {
                logDroppedMessages();
            }
        };
        StorageService.scheduledTasks.scheduleWithFixedDelay(logDropped, LOG_DROPPED_INTERVAL_IN_MS, LOG_DROPPED_INTERVAL_IN_MS, TimeUnit.MILLISECONDS);
    }

    Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, ?> timeoutReporter = new Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, Object>()
    {
        public Object apply(Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>> pair)
        {
            final CallbackInfo expiredCallbackInfo = pair.right.value;
            maybeAddLatency(expiredCallbackInfo.callback, expiredCallbackInfo.target, pair.right.timeout);
            ConnectionMetrics.totalTimeouts.mark();
            getConnectionPool(expiredCallbackInfo.target).incrementTimeout();
            if (expiredCallbackInfo.isFailureCallback())
            {
                StageManager.getStage(Stage.INTERNAL_RESPONSE).submit(new Runnable() {
                    @Override
                    public void run() {
                        ((IAsyncCallbackWithFailure)expiredCallbackInfo.callback).onFailure(expiredCallbackInfo.target);
                    }
                });
            }

            if (expiredCallbackInfo.shouldHint())
            {
                RowMutation rm = (RowMutation) ((WriteCallbackInfo) expiredCallbackInfo).sentMessage.payload;
                return StorageProxy.submitHint(rm, expiredCallbackInfo.target, null);
            }

            return null;
        }
    };

    callbacks = new ExpiringMap<>(DatabaseDescriptor.getMinRpcTimeout(), timeoutReporter);

    if (!testOnly)
    {
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        try
        {
            mbs.registerMBean(this, new ObjectName(MBEAN_NAME));
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }
    }
}

/**
    * Track latency information for the dynamic snitch
    *
    * @param cb      the callback associated with this message -- this lets us know if it's a message type we're interested in
    * @param address the host that replied to the message
    * @param latency
    */
public void maybeAddLatency(IAsyncCallback cb, InetAddress address, long latency)
{
    if (cb.isLatencyForSnitch())
        addLatency(address, latency);
}

public void addLatency(InetAddress address, long latency)
{
    for (ILatencySubscriber subscriber : subscribers)
        subscriber.receiveTiming(address, latency);
}

/**
    * called from gossiper when it notices a node is not responding.
    */
public void convict(InetAddress ep)
{
    logger.debug(""Resetting pool for "" + ep);
    getConnectionPool(ep).reset();
}

/**
    * Listen on the specified port.
    *
    * @param localEp InetAddress whose port to listen on.
    */
public void listen(InetAddress localEp) throws ConfigurationException
{
    callbacks.reset(); // hack to allow tests to stop/restart MS
    for (ServerSocket ss : getServerSockets(localEp))
    {
        SocketThread th = new SocketThread(ss, ""ACCEPT-"" + localEp);
        th.start();
        socketThreads.add(th);
    }
    listenGate.signalAll();
}

private List<ServerSocket> getServerSockets(InetAddress localEp) throws ConfigurationException
{
    final List<ServerSocket> ss = new ArrayList<ServerSocket>(2);
    if (DatabaseDescriptor.getServerEncryptionOptions().internode_encryption != ServerEncryptionOptions.InternodeEncryption.none)
    {
        try
        {
            ss.add(SSLFactory.getServerSocket(DatabaseDescriptor.getServerEncryptionOptions(), localEp, DatabaseDescriptor.getSSLStoragePort()));
        }
        catch (IOException e)
        {
            throw new ConfigurationException(""Unable to create ssl socket"", e);
        }
        // setReuseAddress happens in the factory.
        logger.info(""Starting Encrypted Messaging Service on SSL port {}"", DatabaseDescriptor.getSSLStoragePort());
    }

    if (DatabaseDescriptor.getServerEncryptionOptions().internode_encryption != ServerEncryptionOptions.InternodeEncryption.all)
    {
        ServerSocketChannel serverChannel = null;
        try
        {
            serverChannel = ServerSocketChannel.open();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        ServerSocket socket = serverChannel.socket();
        try
        {
            socket.setReuseAddress(true);
        }
        catch (SocketException e)
        {
            throw new ConfigurationException(""Insufficient permissions to setReuseAddress"", e);
        }
        InetSocketAddress address = new InetSocketAddress(localEp, DatabaseDescriptor.getStoragePort());
        try
        {
            socket.bind(address,500);
        }
        catch (BindException e)
        {
            if (e.getMessage().contains(""in use""))
                throw new ConfigurationException(address + "" is in use by another process.  Change listen_address:storage_port in cassandra.yaml to values that do not conflict with other services"");
            else if (e.getMessage().contains(""Cannot assign requested address""))
                throw new ConfigurationException(""Unable to bind to address "" + address
                                                    + "". Set listen_address in cassandra.yaml to an interface you can bind to, e.g., your private IP address on EC2"");
            else
                throw new RuntimeException(e);
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        logger.info(""Starting Messaging Service on port {}"", DatabaseDescriptor.getStoragePort());
        ss.add(socket);
    }
    return ss;
}

public void waitUntilListening()
{
    try
    {
        listenGate.await();
    }
    catch (InterruptedException ie)
    {
        logger.debug(""await interrupted"");
    }
}

public boolean isListening()
{
    return listenGate.isSignaled();
}

public void destroyConnectionPool(InetAddress to)
{
    OutboundTcpConnectionPool cp = connectionManagers.get(to);
    if (cp == null)
        return;
    cp.close();
    connectionManagers.remove(to);
}
",introduce parameter,"Introduce a new parameter to the ""MessagingService"" method and name it [keyword]:",FALSE,src/java/org/apache/cassandra/net/MessagingService.java,https://github.com/apache/cassandra/commit/573a1d115b86abbe3fb53ff930464d7d8fd95600
1100842,"@NotNull
public static List<CourseInfo> getCourses() {
try {
    List<CourseInfo> result = new ArrayList<CourseInfo>();
    int pageNumber = 0;
    boolean hasNext = addCoursesFromStepic(result, pageNumber);
    while (hasNext) {
    pageNumber += 1;
    hasNext = addCoursesFromStepic(result, pageNumber);
    }
    return result;
}
catch (IOException e) {
    LOG.error(""Cannot load course list "" + e.getMessage());
}
return Collections.emptyList();
}

private static boolean addCoursesFromStepic(List<CourseInfo> result, int pageNumber) throws IOException {
final String url = pageNumber == 0 ? ""courses"" : ""courses?page="" + String.valueOf(pageNumber);
final CoursesContainer coursesContainer = getFromStepic(url, CoursesContainer.class);
final List<CourseInfo> courseInfos = coursesContainer.courses;
for (CourseInfo info : courseInfos) {
    final String courseType = info.getType();
    if (StringUtil.isEmptyOrSpaces(courseType)) continue;
    final List<String> typeLanguage = StringUtil.split(courseType, "" "");
    if (typeLanguage.size() == 2 && PYCHARM_PREFIX.equals(typeLanguage.get(0))) {
    result.add(info);
    }
}
return coursesContainer.meta.containsKey(""has_next"") && coursesContainer.meta.get(""has_next"") == Boolean.TRUE;
}

public static Course getCourse(@NotNull final CourseInfo info) {
final Course course = new Course();
course.setAuthors(info.getInstructors());
course.setDescription(info.getDescription());
course.setName(info.getName());
String courseType = info.getType();
course.setLanguage(courseType.substring(PYCHARM_PREFIX.length() + 1));
course.setUpToDate(true);  // TODO: get from stepic
try {
    for (Integer section : info.sections) {
    course.addLessons(getLessons(section));
    }
    return course;
}
catch (IOException e) {
    LOG.error(""IOException "" + e.getMessage());
}
return null;
}

public static List<Lesson> getLessons(int sectionId) throws IOException {
final SectionWrapper sectionWrapper = getFromStepic(""sections/"" + String.valueOf(sectionId), SectionWrapper.class);
List<Integer> unitIds = sectionWrapper.sections.get(0).units;
final List<Lesson> lessons = new ArrayList<Lesson>();
for (Integer unitId : unitIds) {
    UnitWrapper unit = getFromStepic(""units/"" + String.valueOf(unitId), UnitWrapper.class);
    int lessonID = unit.units.get(0).lesson;
    LessonContainer lesson = getFromStepic(""lessons/"" + String.valueOf(lessonID), LessonContainer.class);
    Lesson realLesson = lesson.lessons.get(0);
    lessons.add(realLesson);
}

for (Lesson lesson : lessons) {
    lesson.taskList = new ArrayList<Task>();
    for (Integer s : lesson.steps) {
    createTask(lesson, s);
    }
}
return lessons;
}

private static void createTask(Lesson lesson, Integer s) throws IOException {
final Step step = getStep(s);
final Task task = new Task();
task.setName(step.options != null ? step.options.title : PYCHARM_PREFIX);
task.setText(step.text);
for (TestFileWrapper wrapper : step.options.test) {
    task.setTestsTexts(wrapper.name, wrapper.text);
}

task.taskFiles = new HashMap<String, TaskFile>();      // TODO: it looks like we don't need taskFiles as map anymore
if (step.options.files != null) {
    for (TaskFile taskFile : step.options.files) {
    task.taskFiles.put(taskFile.name, taskFile);
    }
}
lesson.taskList.add(task);
}

public static Step getStep(Integer step) throws IOException {
return getFromStepic(""steps/"" + String.valueOf(step), StepContainer.class).steps.get(0).block;
}


public static void showLoginDialog() {
final LoginDialog dialog = new LoginDialog();
dialog.show();
}


public static void postLesson(Project project, @NotNull final Lesson lesson) {
final HttpPost request = new HttpPost(stepicApiUrl + ""lessons"");
if (ourClient == null) {
    showLoginDialog();
}

setHeaders(request, ""application/json"");
String requestBody = new Gson().toJson(new LessonWrapper(lesson));
request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));

try {
    final CloseableHttpResponse response = ourClient.execute(request);
    final String responseString = EntityUtils.toString(response.getEntity());
    final StatusLine line = response.getStatusLine();
    if (line.getStatusCode() != 201) {
    LOG.error(""Failed to push "" + responseString);
    return;
    }
    final Lesson postedLesson = new Gson().fromJson(responseString, Course.class).getLessons().get(0);
    for (Task task : lesson.getTaskList()) {
    postTask(project, task, postedLesson.id);
    }
}
catch (IOException e) {
    LOG.error(e.getMessage());
}
}

public static void postTask(Project project, @NotNull final Task task, int id) {
final HttpPost request = new HttpPost(stepicApiUrl + ""step-sources"");
setHeaders(request, ""application/json"");
final Gson gson = new GsonBuilder().setPrettyPrinting().excludeFieldsWithoutExposeAnnotation().create();
String requestBody = gson.toJson(new StepSourceWrapper(project, task, id));
request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));

try {
    final CloseableHttpResponse response = ourClient.execute(request);
    final StatusLine line = response.getStatusLine();
    if (line.getStatusCode() != 201) {
    LOG.error(""Failed to push "" + EntityUtils.toString(response.getEntity()));
    }
}
catch (IOException e) {
    LOG.error(e.getMessage());
}
}

private static void setHeaders(@NotNull final HttpRequestBase request, String contentType) {
request.addHeader(new BasicHeader(""referer"", stepicUrl));
request.addHeader(new BasicHeader(""X-CSRFToken"", ourCSRFToken));
request.addHeader(new BasicHeader(""content-type"", contentType));
}

private static class StepContainer {
List<StepSource> steps;
}

private static class Step {
@Expose StepOptions options;
@Expose String text;
@Expose String name = ""pycharm"";
@Expose StepOptions source;

public static Step fromTask(Project project, @NotNull final Task task) {
    final Step step = new Step();
    step.text = task.getTaskText(project);
    step.source = StepOptions.fromTask(project, task);
    return step;
}
}

private static class StepOptions {
@Expose List<TestFileWrapper> test;
@Expose String title;  //HERE
@Expose List<TaskFile> files;
@Expose String text;

public static StepOptions fromTask(final Project project, @NotNull final Task task) {
    final StepOptions source = new StepOptions();

    final String text = task.getTestsText(project);
    source.test = Collections.singletonList(new TestFileWrapper(""tests.py"", text));
    source.files = new ArrayList<TaskFile>();
    source.title = task.getName();
    for (final Map.Entry<String, TaskFile> entry : task.getTaskFiles().entrySet()) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
        @Override
        public void run() {
        final VirtualFile taskDir = task.getTaskDir(project);
        assert taskDir != null;
        EduUtils.createStudentFileFromAnswer(project, taskDir, taskDir, entry);
        }
    });
    final TaskFile taskFile = entry.getValue();
    taskFile.name = entry.getKey();
    final Document document = task.getDocument(project, taskFile.name);
    if (document != null) {
        source.text = document.getImmutableCharSequence().toString();
        taskFile.text = document.getImmutableCharSequence().toString();
    }
    source.files.add(taskFile);
    }
    return source;
}
}",extract variable,"Extract variable ""coursesContainer"" from the ""addCoursesFromStepic"" method and name it [keyword]:",TRUE,python/educational/src/com/jetbrains/edu/stepic/EduStepicConnector.java,https://github.com/JetBrains/intellij-community/commit/7ed3f273ab0caf0337c22f0b721d51829bb0c877
1100663,"public class ScrollableToolbarPopupMenu extends ToolbarPopupMenu
{
   @Override
   protected ToolbarMenuBar createMenuBar()
   {
      final ScrollableToolbarMenuBar menuBar = new ScrollableToolbarMenuBar(true);
      menuBar.addSelectionHandler(new SelectionHandler<MenuItem>()
      {
         public void onSelection(SelectionEvent<MenuItem> event)
         {
            ensureSelectedIsVisible();
         }
      });
      return menuBar;
   }
   
   public HandlerRegistration addSelectionHandler(SelectionHandler<MenuItem> handler)
   {
      return ((ScrollableToolbarMenuBar)menuBar_).addSelectionHandler(handler);
   }


   public void ensureSelectedIsVisible()
   {
      if (menuBar_.getSelectedItem() != null)
      {
         DomUtils.ensureVisibleVert(scrollPanel_.getElement(),
                                    menuBar_.getSelectedItem().getElement(),
                                    0);
      }
   }
   
   public int getSelectedIndex()
   {
      return menuBar_.getSelectedIndex();
   }

   @Override
   protected Widget wrapMenuBar(ToolbarMenuBar menuBar)
   {
      scrollPanel_ = new ScrollPanel(menuBar);
      scrollPanel_.addStyleName(ThemeStyles.INSTANCE.scrollableMenuBar());
      scrollPanel_.getElement().getStyle().setOverflowY(Overflow.AUTO);
      scrollPanel_.getElement().getStyle().setOverflowX(Overflow.HIDDEN);
      setMaxHeight(getMaxHeight());
      return scrollPanel_;
   }
   
   protected int getMaxHeight()
   {
      return 300;
   }
   
   protected void setMaxHeight(int maxHeight)
   {
      scrollPanel_.getElement().getStyle().setProperty(""maxHeight"", 
            maxHeight + ""px"");
   }

   protected class ScrollableToolbarMenuBar extends ToolbarMenuBar
      implements HasSelectionHandlers<MenuItem>
   {
      public ScrollableToolbarMenuBar(boolean vertical)
      {
         super(vertical);
      }

      public HandlerRegistration addSelectionHandler(
            SelectionHandler<MenuItem> handler)
      {
         return addHandler(handler, SelectionEvent.getType());
      }

      @Override
      public void selectItem(MenuItem item)
      {
         super.selectItem(item);
         SelectionEvent.fire(this, item);
      }
   }

   private ScrollPanel scrollPanel_;
}

public class ToolbarPopupMenu extends ThemedPopupPanel
                              implements CommandHandler
{
   // Extensibility point for dynamically constructed popup menus. The default
   // implementation returns itself, but extensions can do some work to build
   // the menu and return the built menu. Callers can use this in combination
   // with getDynamicPopupMenu() when an up-to-date instance of the object is
   // required.
   public interface DynamicPopupMenuCallback
   {
      void onPopupMenu(ToolbarPopupMenu menu);
   }

   /**
    * Does the control receive keyboard focus?
    */
   public enum ReceivesFocus
   {
      NO,
      YES
   }

   public ToolbarPopupMenu()
   {
      super(true);
      menuBar_ = createMenuBar();
      Widget mainWidget = createMainWidget();
      setWidget(mainWidget);
      events_ = RStudioGinjector.INSTANCE.getEventBus();
      commandHandler_ = new HandlerRegistrations();
      getElement().getStyle().setZIndex(1000);
   }

   public ToolbarPopupMenu(ToolbarPopupMenu parent)
   {
      this();
      parent_ = parent;
   }

   /**
    * Position popup relative to a point, typically for a right-click context menu
    * @param clientX
    * @param clientY
    * @param elementId - unique elementId for automation
    */
   public void showRelativeTo(int clientX, int clientY, String elementId)
   {
      ElementIds.assignElementId(this, elementId);
      setPopupPositionAndShow((offsetWidth, offsetHeight) ->
      {
         // Calculate left position for the popup; normally the clicked location but
         // if it doesn't fix horizontally nudge it to the left
         int left = clientX;

         // Make sure scrolling is taken into account, since
         // box.getAbsoluteLeft() takes scrolling into account.
         int windowRight = Window.getClientWidth() + Window.getScrollLeft();
         int windowLeft = Window.getScrollLeft();

         // Distance from the clicked location to the right edge of the window
         int distanceToWindowRight = windowRight - clientX;

         // Distance from the clicked location to the left edge of the window
         int distanceFromWindowLeft = clientX - windowLeft;

         // If there is not enough space for the overflow of the popup's
         // width to the right, and there IS enough space for the
         // overflow to the left, then right-align the popup.
         // However, if there is not enough space on either side, then stick with
         // left-alignment.
         if (distanceToWindowRight < offsetWidth && distanceFromWindowLeft >= offsetWidth)
         {
            // Align the right edge of popup with clicked location
            left -= offsetWidth;
         }

         // Calculate top position for the popup; normally we expand ""down"" from where user
         // right-clicked but if there isn't room them expand ""up""
         int top = clientY;

         // Make sure scrolling is taken into account, since
         // box.getAbsoluteTop() takes scrolling into account. We don't normally
         // allow the main window to be scrolled, but just in case.
         int windowTop = Window.getScrollTop();
         int windowBottom = Window.getScrollTop() + Window.getClientHeight();

         // Distance from the top edge of the window to the clicked location
         int distanceFromWindowTop = top - windowTop;

         // Distance from the bottom edge of the window to the clicked location
         int distanceToWindowBottom = windowBottom - top;

         // If there is not enough space for the popup's height below the clicked
         // location and there IS enough space for the popup's height above the
         // clicked location, then position the popup above the location. However, if there
         // is not enough space on either side, then stick with displaying the
         // popup below the clicked location.
         if (distanceToWindowBottom < offsetHeight && distanceFromWindowTop >= offsetHeight)
         {
            top -= offsetHeight;
         }
         setAutoConstrain(false);
         setPopupPosition(left, top);
      });
   }

   protected ToolbarMenuBar createMenuBar()
   {
      return new ToolbarMenuBar(true);
   }

   protected Widget createMainWidget()
   {
      return menuBar_;
   }

   @Override
   protected void onLoad()
   {
      super.onLoad();
      commandHandler_.add(events_.addHandler(CommandEvent.TYPE, this));
   }

   @Override
   protected void onUnload()
   {
      super.onUnload();
      menuBar_.selectItem(null);
      commandHandler_.removeHandler();
   }

   public void selectFirst()
   {
      menuBar_.selectFirst();
   }

   public void selectLast()
   {
      menuBar_.selectLast();
   }

   public void moveSelectionFwd(int numElements)
   {
      menuBar_.moveSelectionFwd(numElements);
   }

   public void moveSelectionBwd(int numElements)
   {
      menuBar_.moveSelectionBwd(numElements);
   }

   public void selectItem(MenuItem menuItem)
   {
      menuBar_.selectItem(menuItem);
   }

   public void addItem(String menuElementId, MenuItem menuItem)
   {
      addItem(menuItem);
      ElementIds.assignElementId(menuItem.getElement(), menuElementId);
   }

   public void addItem(MenuItem menuItem)
   {
      ScheduledCommand command = menuItem.getScheduledCommand();
      if (command == null && menuItem instanceof AppMenuItem)
      {
         AppMenuItem appMenuItem = (AppMenuItem) menuItem;
         command = appMenuItem.getScheduledCommand(true);
      }

      if (command != null)
         menuItem.setScheduledCommand(new ToolbarPopupMenuCommand(command));

      menuBar_.addItem(menuItem);
   }
}",extract method,"Extract a method from the protected ""wrapMenuBar"" that sets the maxHeight property and name it [keyword]:",TRUE,src/gwt/src/org/rstudio/core/client/widget/ScrollableToolbarPopupMenu.java,https://github.com/rstudio/rstudio/commit/cb49e436b9d7ee55f2531ebc2ef1863f5c9ba9fe
1159839,"@API(Internal)
public class ClassTestDescriptor extends JUnit5TestDescriptor implements Container<JUnit5EngineExecutionContext> {

	private static final ConditionEvaluator conditionEvaluator = new ConditionEvaluator();

	private final String displayName;

	private final Class<?> testClass;

	private final List<Method> beforeAllMethods;

	private final List<Method> afterAllMethods;

	private final List<Method> beforeEachMethods;

	private final List<Method> afterEachMethods;

	public ClassTestDescriptor(UniqueId uniqueId, Class<?> testClass) {
		super(uniqueId);

		this.testClass = Preconditions.notNull(testClass, ""Class must not be null"");
		this.displayName = determineDisplayName(testClass, testClass.getName());

		this.beforeAllMethods = findBeforeAllMethods(testClass);
		this.afterAllMethods = findAfterAllMethods(testClass);
		this.beforeEachMethods = findBeforeEachMethods(testClass);
		this.afterEachMethods = findAfterEachMethods(testClass);

		setSource(new JavaSource(testClass));
	}

	public final Class<?> getTestClass() {
		return this.testClass;
	}

	@Override
	public final String getName() {
		return getTestClass().getName();
	}

	@Override
	public final String getDisplayName() {
		return this.displayName;
	}

	@Override
	public Set<TestTag> getTags() {
		return getTags(this.testClass);
	}

	@Override
	public final boolean isTest() {
		return false;
	}

	@Override
	public final boolean isContainer() {
		return true;
	}

	@Override
	public JUnit5EngineExecutionContext prepare(JUnit5EngineExecutionContext context) {
		ExtensionRegistry registry = populateNewExtensionRegistryFromExtendWith(this.testClass,
			context.getExtensionRegistry());

		registerBeforeEachMethodAdapters(registry);
		registerAfterEachMethodAdapters(registry);

		context = context.extend().withExtensionRegistry(registry).build();

		ContainerExtensionContext containerExtensionContext = new ClassBasedContainerExtensionContext(
			context.getExtensionContext(), context.getExecutionListener(), this);

		// @formatter:off
		return context.extend()
				.withTestInstanceProvider(testInstanceProvider(context))
				.withExtensionContext(containerExtensionContext)
				.build();
		// @formatter:on
	}

	@Override
	public SkipResult shouldBeSkipped(JUnit5EngineExecutionContext context) throws Exception {
		ConditionEvaluationResult evaluationResult = conditionEvaluator.evaluateForContainer(
			context.getExtensionRegistry(), (ContainerExtensionContext) context.getExtensionContext());
		if (evaluationResult.isDisabled()) {
			return SkipResult.skip(evaluationResult.getReason().orElse(""<unknown>""));
		}
		return SkipResult.dontSkip();
	}

	@Override
	public JUnit5EngineExecutionContext beforeAll(JUnit5EngineExecutionContext context) throws Exception {
		ExtensionRegistry registry = context.getExtensionRegistry();
		ContainerExtensionContext extensionContext = (ContainerExtensionContext) context.getExtensionContext();

		invokeBeforeAllCallbacks(registry, extensionContext);
		invokeBeforeAllMethods(registry, extensionContext);

		return context;
	}

	@Override
	public JUnit5EngineExecutionContext afterAll(JUnit5EngineExecutionContext context) throws Exception {
		ExtensionRegistry registry = context.getExtensionRegistry();
		ContainerExtensionContext extensionContext = (ContainerExtensionContext) context.getExtensionContext();
		ThrowableCollector throwableCollector = new ThrowableCollector();

		invokeAfterAllMethods(registry, extensionContext, throwableCollector);
		invokeAfterAllCallbacks(registry, extensionContext, throwableCollector);
		throwableCollector.assertEmpty();

		return context;
	}

	protected TestInstanceProvider testInstanceProvider(JUnit5EngineExecutionContext context) {
		return () -> ReflectionUtils.newInstance(testClass);
	}

	private void invokeBeforeAllCallbacks(ExtensionRegistry registry, ContainerExtensionContext context) {
		registry.stream(BeforeAllCallback.class)//
				.forEach(extension -> executeAndMaskThrowable(() -> extension.beforeAll(context)));
	}

	private void invokeBeforeAllMethods(ExtensionRegistry registry, ContainerExtensionContext context) {
		this.beforeAllMethods.forEach(method -> executeAndMaskThrowable(
			() -> new MethodInvoker(context, registry).invoke(methodInvocationContext(null, method))));
	}

	private void invokeAfterAllMethods(ExtensionRegistry registry, ContainerExtensionContext context,
			ThrowableCollector throwableCollector) {

		this.afterAllMethods.forEach(method -> throwableCollector.execute(
			() -> new MethodInvoker(context, registry).invoke(methodInvocationContext(null, method))));
	}

	private void invokeAfterAllCallbacks(ExtensionRegistry registry, ContainerExtensionContext context,
			ThrowableCollector throwableCollector) {

		registry.reverseStream(AfterAllCallback.class)//
				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(context)));
	}

	private void registerBeforeEachMethodAdapters(ExtensionRegistry registry) {
		registerMethodsAsExtensions(this.beforeEachMethods, registry, this::synthesizeBeforeEachMethodAdapter);
	}

	private void registerAfterEachMethodAdapters(ExtensionRegistry registry) {
		registerMethodsAsExtensions(this.afterEachMethods, registry, this::synthesizeAfterEachMethodAdapter);
	}

	private void registerMethodsAsExtensions(List<Method> methods, ExtensionRegistry registry,
			BiFunction<ExtensionRegistry, Method, Extension> extensionSynthesizer) {

		methods.forEach(method -> registry.registerExtension(extensionSynthesizer.apply(registry, method), method));
	}

	private BeforeEachMethodAdapter synthesizeBeforeEachMethodAdapter(ExtensionRegistry registry, Method method) {
		return extensionContext -> invokeMethodInTestExtensionContext(method, extensionContext, registry);
	}

	private AfterEachMethodAdapter synthesizeAfterEachMethodAdapter(ExtensionRegistry registry, Method method) {
		return extensionContext -> invokeMethodInTestExtensionContext(method, extensionContext, registry);
	}

	private void invokeMethodInTestExtensionContext(Method method, TestExtensionContext context,
			ExtensionRegistry registry) {

		Object instance = ReflectionUtils.getOuterInstance(context.getTestInstance(),
			method.getDeclaringClass()).orElseThrow(
				() -> new JUnitException(""Failed to find instance for method: "" + method.toGenericString()));

		new MethodInvoker(context, registry).invoke(methodInvocationContext(instance, method));
	}

}",extract class,Extract a class to manage the lifecycle and name it [keyword]:,TRUE,junit5-engine/src/main/java/org/junit/gen5/engine/junit5/descriptor/ClassTestDescriptor.java,https://github.com/junit-team/junit5/commit/6b575f2ee5f02288a774ff0a85ce3a3e3cb6946f
1137389,"class Rule {
    private final String name;
    public Rule(String name) { this.name = name; }
    public String getName() { return name; }
}

public class Script {
    List<Rule> rules = new ArrayList<>();
    private String fileName;
    private ScriptManager scriptManager;
        private ScriptEngine engine = null;

    public Script(ScriptManager scriptManager, File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
        this.scriptManager = scriptManager;
        this.fileName = file.getName();
        loadScript(file);
        }

    public List<Rule> getRules() {
        return rules;
    }

    public void addRule(Rule rule) {
        rules.add(rule);
    }

    public void addRules(List<Rule> newRules) {
        rules.addAll(newRules);
    }

    public void removeRule(Rule rule) {
        rules.remove(rule);
    }

    public void executeAllRules() {
        for (Rule r : rules) {
            System.out.println(""Executing rule: "" + r.getName());
        }
    }

    public String getFileName() {
        return fileName;
    }

        public void loadScript(File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
                logger.info(""Loading Script "" + file.getName());
                String extension = getFileExtension(file);
                ScriptEngineManager factory = new ScriptEngineManager();
                engine = factory.getEngineByExtension(extension);
                if (engine != null) {
                        logger.info(""EngineName: "" + engine.getFactory().getEngineName());
                        initializeSciptGlobals();
                        engine.eval(new FileReader(file));
                        Invocable inv = (Invocable) engine;
                        RuleSet ruleSet = (RuleSet) inv.invokeFunction(""getRules"");
                        rules.addAll(ruleSet.getRules());
                }
        }

        private void initializeSciptGlobals() {
                if(engine.getFactory().getEngineName().toLowerCase().endsWith(""nashorn"")){
                        initializeNashornGlobals();
                }else{
                        initializeGeneralGlobals();
                }
        }

private void initializeNashornGlobals() {
                if( !Script.class.getClassLoader().getParent().toString().contains(""ExtClassLoader"") ){                                
                        logger.warn(""Found wrong classloader: To prevent Class loading Problems use this directive in start.sh/-.bat: -Dorg.osgi.framework.bundle.parent=ext"");
                }
                try {
                        
                        logger.info(""initializeSciptGlobals for : "" + engine.getFactory().getEngineName());                        
                        engine.put(""ItemRegistry"",                 scriptManager.getItemRegistry());
                        engine.put(""ir"",                                 scriptManager.getItemRegistry());
                        engine.eval(""var shared = org.openhab.core.jsr223.internal.shared,\n""
                                +""RuleSet                                 = Java.type('org.openhab.core.jsr223.internal.shared.RuleSet'),\n""
                                +""Rule                                         = Java.type('org.openhab.core.jsr223.internal.shared.Rule'),\n""
                                +""ChangedEventTrigger         = Java.type('org.openhab.core.jsr223.internal.shared.ChangedEventTrigger'),\n""
                                +""CommandEventTrigger         = Java.type('org.openhab.core.jsr223.internal.shared.CommandEventTrigger'),\n""
                                +""Event                                 = Java.type('org.openhab.core.jsr223.internal.shared.Event'),\n""
                                +""EventTrigger                        = Java.type('org.openhab.core.jsr223.internal.shared.EventTrigger'),\n""
                                +""ShutdownTrigger                 = Java.type('org.openhab.core.jsr223.internal.shared.ShutdownTrigger'),\n""
                                +""StartupTrigger                 = Java.type('org.openhab.core.jsr223.internal.shared.StartupTrigger'),\n""
                                +""TimerTrigger                         = Java.type('org.openhab.core.jsr223.internal.shared.TimerTrigger'),\n""
                                +""TriggerType                         = Java.type('org.openhab.core.jsr223.internal.shared.TriggerType'),\n""
                                +""PersistenceExtensions        = Java.type('org.openhab.core.persistence.extensions.PersistenceExtensions'),\n""
                                +""pe                                        = Java.type('org.openhab.core.persistence.extensions.PersistenceExtensions'),\n""
                                +""oh                                         = Java.type('org.openhab.core.jsr223.internal.shared.Openhab'),\n""
                                +""State                                 = Java.type('org.openhab.core.types.State'),\n""
                                +""Command                                 = Java.type('org.openhab.core.types.Command'),\n""
                                +""DateTime                                 = Java.type('org.joda.time.DateTime'),\n""
                                +""StringUtils                         = Java.type('org.apache.commons.lang.StringUtils'),\n""
                                +""URLEncoder                         = Java.type('java.net.URLEncoder'),\n""

                                +""CallType                                 = Java.type('org.openhab.library.tel.types.CallType'),\n""
                                +""DateTimeType                         = Java.type('org.openhab.core.library.types.DateTimeType'),\n""
                                +""DecimalType                         = Java.type('org.openhab.core.library.types.DecimalType'),\n""
                                +""HSBType                                 = Java.type('org.openhab.core.library.types.HSBType'),\n""
                                +""IncreaseDecreaseType         = Java.type('org.openhab.core.library.types.IncreaseDecreaseType'),\n""
                                +""OnOffType                         = Java.type('org.openhab.core.library.types.OnOffType'),\n""
                                +""OpenClosedType                 = Java.type('org.openhab.core.library.types.OpenClosedType'),\n""
                                +""PercentType                         = Java.type('org.openhab.core.library.types.PercentType'),\n""
                                +""PointType                         = Java.type('org.openhab.core.library.types.PointType'),\n""
                                +""StopMoveType                         = Java.type('org.openhab.core.library.types.StopMoveType'),\n""
                                +""UpDownType                         = Java.type('org.openhab.core.library.types.UpDownType'),\n""
                                +""StringType                         = Java.type('org.openhab.core.library.types.StringType'),\n""
                                
                                //As of now, Nashorn does not support calling super class methods.
                                //http://nashorn-dev.openjdk.java.narkive.com/VX59ksgk/calling-super-methods-when-extending-classes
                                //therefore:
                                +""BusEvent                                 = Java.type('org.openhab.model.script.actions.BusEvent'),\n""
                                +""be                                         = Java.type('org.openhab.model.script.actions.BusEvent'),\n""
                                
                                +""transform                         = oh.getAction('Transformation').static.transform,\n""
                                
                                //Item
                                +""getItem                                 = ItemRegistry.getItem,\n""
                                +""postUpdate                         = BusEvent.postUpdate,\n""
                                +""sendCommand                         = BusEvent.sendCommand,\n""
                                
                                //System
                                +""FileUtils                         = Java.type('org.apache.commons.io.FileUtils'),\n""
                                +""FilenameUtils                        = Java.type('org.apache.commons.io.FilenameUtils'),\n""
                                +""File                                         = Java.type('java.io.File'),\n""
                                
                                +""ohEngine                                = 'javascript';\n""
                                
                                //Helper Functions and Libs eventually later a lib Folder for default (Auto) loaded Libraries
                                //Bas64: https://gist.github.com/ncerminara/11257943
                                //+""load('configurations/scripts/jslib/b64.js');\n""
                        );
                        
                } catch (ScriptException e) {
                        logger.error(""ScriptException in initializeSciptGlobals while importing default-classes: "", e);
                }
        }

        private void initializeGeneralGlobals() {
                engine.put(""RuleSet"",                                 RuleSet.class);
                engine.put(""Rule"",                                         Rule.class);
                engine.put(""ChangedEventTrigger"",         ChangedEventTrigger.class);
                engine.put(""CommandEventTrigger"",         CommandEventTrigger.class);
                engine.put(""Event"",                                 Event.class);
                engine.put(""EventTrigger"",                         EventTrigger.class);
                engine.put(""ShutdownTrigger"",                 ShutdownTrigger.class);
                engine.put(""StartupTrigger"",                 StartupTrigger.class);
                engine.put(""TimerTrigger"",                         TimerTrigger.class);
                engine.put(""TriggerType"",                         TriggerType.class);
                engine.put(""BusEvent"",                                 BusEvent.class);
                engine.put(""be"",                                         BusEvent.class);
                engine.put(""PersistenceExtensions"", PersistenceExtensions.class);
                engine.put(""pe"",                                         PersistenceExtensions.class);
                engine.put(""oh"",                                         Openhab.class);
                engine.put(""State"",                                 State.class);
                engine.put(""Command"",                                 Command.class);
                engine.put(""ItemRegistry"",                         scriptManager.getItemRegistry());
                engine.put(""ir"",                                         scriptManager.getItemRegistry());
                engine.put(""DateTime"",                                 DateTime.class);
                engine.put(""StringUtils"",                         StringUtils.class);
                engine.put(""URLEncoder"",                         URLEncoder.class);        
                engine.put(""FileUtils"",                         FileUtils.class);        
                engine.put(""FilenameUtils"",                 FilenameUtils.class);        
                engine.put(""File"",                                         File.class);                        

                // default types, TODO: auto import would be nice
                engine.put(""CallType"",                                 CallType.class);
                engine.put(""DateTimeType"",                         DateTimeType.class);
                engine.put(""DecimalType"",                         DecimalType.class);
                engine.put(""HSBType"",                                 HSBType.class);
                engine.put(""IncreaseDecreaseType"",         IncreaseDecreaseType.class);
                engine.put(""OnOffType"",                         OnOffType.class);
                engine.put(""OpenClosedType"",                 OpenClosedType.class);
                engine.put(""PercentType"",                         PercentType.class);
                engine.put(""PointType"",                         PointType.class);
                engine.put(""StopMoveType"",                         StopMoveType.class);
                engine.put(""UpDownType"",                         UpDownType.class);
                engine.put(""StringType"",                         StringType.class);
        }
}",Encapsulate Collection,Encapsulate the rules collection by adding methods to manage its additions and removals. Name them add[keyword] and remove[keyword]:,FALSE,bundles/core/org.openhab.core.jsr223/src/main/java/org/openhab/core/jsr223/internal/engine/scriptmanager/Script.java,https://github.com/openhab/openhab/commit/cf1efb6d27a4037cdbe5a780afa6053859a60d4a
1137389,"public class ScriptManager {
	static private final Logger logger = LoggerFactory.getLogger(ScriptManager.class);

	public HashMap<String, Script> scripts = new HashMap<String, Script>();
	public HashMap<Rule, Script> ruleMap = new HashMap<Rule, Script>();

	private ItemRegistry itemRegistry;

	private RuleTriggerManager triggerManager;

	private Thread scriptUpdateWatcher;

	private static ScriptManager instance;

	public ScriptManager(RuleTriggerManager triggerManager, ItemRegistry itemRegistry) {
		this.triggerManager = triggerManager;
		instance = this;
		logger.info(""Available engines:"");
		for (ScriptEngineFactory f : new ScriptEngineManager().getEngineFactories()) {
			logger.info(f.getEngineName());
		}

		this.setItemRegistry(itemRegistry);

		File folder = getFolder(""scripts"");

		if (folder.exists() && folder.isDirectory()) {
			loadScripts(folder);

			scriptUpdateWatcher = new Thread(new ScriptUpdateWatcher(this, folder));
			scriptUpdateWatcher.start();
		} else {
			logger.warn(""Script directory: jsr_scripts missing, no scripts will be added!"");
		}
	}

	public void scriptsChanged(List<File> addedScripts, List<File> removedScripts, List<File> modifiedScripts) {

		for (File scriptFile : removedScripts) {
			removeScript(scriptFile.getName());
		}

		for (File scriptFile : addedScripts) {
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}

		for (File scriptFile : modifiedScripts) {
			removeScript(scriptFile.getName());
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}
	}

	public void loadScripts(File folder) {
		for (File file : folder.listFiles()) {
			loadScript(file);
		}
	}

	private Script loadScript(File file) {
		Script script = null;
		try {
			//Filtering Directories and not usable Files
			if(!file.isFile() || file.getName().startsWith(""."") || getFileExtension(file) == null){
				return null;
			}
			script = new Script(this, file);
			if(script.getEngine() == null){
				logger.warn(""No Engine found for File: {}"", file.getName());
				return null;
			}else{
				logger.info(""Engine found for File: {}"", file.getName());
				scripts.put(file.getName(), script);
				List<Rule> newRules = script.getRules();
				for (Rule rule : newRules) {
					ruleMap.put(rule, script);
				}

				// add all rules to the needed triggers
				triggerManager.addRuleModel(newRules);
			}

		} catch(NoSuchMethodException e) {
			logger.error(""Script file misses mandotary function: getRules()"", e);
		} catch (FileNotFoundException e) {
			logger.error(""script file not found"", e);
		} catch (ScriptException e) {
			logger.error(""script exception"", e);
		} catch (Exception e) {
			logger.error(""unknown exception"", e);
		}

		return script;
	}

	public static ScriptManager getInstance() {
		return instance;
	}

	public Collection<Rule> getAllRules() {
		return ruleMap.keySet();
	}

	public ItemRegistry getItemRegistry() {
		return itemRegistry;
	}

	public void setItemRegistry(ItemRegistry itemRegistry) {
		this.itemRegistry = itemRegistry;
	}

	public synchronized void executeRules(Rule[] rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}

	public synchronized void executeRules(Iterable<Rule> rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}

	/**
	 * returns the {@link File} object for a given foldername
	 * 
	 * @param foldername
	 *            the foldername to get the {@link File} for
	 * @return the corresponding {@link File}
	 */
	private File getFolder(String foldername) {
		File folder = new File(ConfigDispatcher.getConfigFolder() + File.separator + foldername);
		return folder;
	}

	public Script getScript(Rule rule) {
		return ruleMap.get(rule);
	}

	private String getFileExtension(File file) {
		String extension = null;
		if (file.getName().contains(""."")) {
			String name = file.getName();
			extension = name.substring(name.lastIndexOf('.') + 1, name.length());
		}
		return extension;
	}

	private void runStartupRules(Script script) {
		if (script != null) {
			ArrayList<Rule> toTrigger = new ArrayList<Rule>();
			for (Rule rule : script.getRules()) {
				for (EventTrigger trigger : rule.getEventTrigger()) {
					if (trigger instanceof StartupTrigger) {
						toTrigger.add(rule);
						break;
					}
				}
			}
			if (toTrigger.size() > 0)
				executeRules(toTrigger, new Event(TriggerType.STARTUP, null, null, null, null));
		}
	}

	private void removeScript(String scriptName) {
		if(scripts.containsKey(scriptName)) {
			Script script = scripts.remove(scriptName);

			List<Rule> allRules = script.getRules();

			triggerManager.removeRuleModel(allRules);
			for (Rule rule : allRules) {
				ruleMap.remove(rule);
			}
		}
	}

}",Encapsulate Record,Apply Encapsulate Record to scriptsChanged by introducing an immutable value object and name it [keyword]:,FALSE,bundles/core/org.openhab.core.jsr223/src/main/java/org/openhab/core/jsr223/internal/engine/scriptmanager/Script.java,https://github.com/openhab/openhab/commit/cf1efb6d27a4037cdbe5a780afa6053859a60d4a
1109077,"@JacksonStdImpl
public class BeanPropertyWriter extends PropertyWriter
    implements BeanProperty
{
    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;

    protected final AnnotatedMember _member;
    protected final Annotations _contextAnnotations;
    protected final JavaType _declaredType;
    protected final Method _accessorMethod;
    protected final Field _field;
    protected HashMap<Object,Object> _internalSettings;
    protected final SerializedString _name;
    protected final PropertyName _wrapperName;
    protected final JavaType _cfgSerializationType;
    protected JavaType _nonTrivialBaseType;
    protected final PropertyMetadata _metadata;
    protected JsonSerializer<Object> _serializer;
    protected JsonSerializer<Object> _nullSerializer;
    protected final TypeSerializer _typeSerializer;
    protected transient PropertySerializerMap _dynamicSerializers;
    protected final boolean _suppressNulls;
    protected final Object _suppressableValue;
    protected final Class<?>[] _includeInViews;

    @SuppressWarnings(""unchecked"")
    public BeanPropertyWriter(BeanPropertyDefinition propDef,
            AnnotatedMember member, Annotations contextAnnotations,
            JavaType declaredType,
            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,
            boolean suppressNulls, Object suppressableValue)
    {
        _member = member;
        _contextAnnotations = contextAnnotations;

        _name = new SerializedString(propDef.getName());
        _wrapperName = propDef.getWrapperName();
        _metadata = propDef.getMetadata();
        _includeInViews = propDef.findViews();

        _declaredType = declaredType;
        _serializer = (JsonSerializer<Object>) ser;
        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyForProperties() : null;
        _typeSerializer = typeSer;
        _cfgSerializationType = serType;

        if (member instanceof AnnotatedField) {
            _accessorMethod = null;
            _field = (Field) member.getMember();
        } else if (member instanceof AnnotatedMethod) {
            _accessorMethod = (Method) member.getMember();
            _field = null;
        } else {
            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props
            _accessorMethod = null;
            _field = null;
        }
        _suppressNulls = suppressNulls;
        _suppressableValue = suppressableValue;

        // this will be resolved later on, unless nulls are to be suppressed
        _nullSerializer = null;
    }

    protected BeanPropertyWriter() {
        _member = null;
        _contextAnnotations = null;

        _name = null;
        _wrapperName = null;
        _metadata = null;
        _includeInViews = null;

        _declaredType = null;
        _serializer = null;
        _dynamicSerializers = null;
        _typeSerializer = null;
        _cfgSerializationType = null;

        _accessorMethod = null;
        _field = null;
        _suppressNulls = false;
        _suppressableValue = null;

        _nullSerializer = null;
    }

    /**
     * ""Copy constructor"" to be used by filtering sub-classes
     */
    protected BeanPropertyWriter(BeanPropertyWriter base) {
        this(base, base._name);
    }

    /**
     * @since 2.5
     */
    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)
    {
        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency
         *   to MapperConfig to encode, and Afterburner having heartburn
         *   for SerializableString (vs SerializedString).
         *   Hope it can be resolved/reworker in 2.6 timeframe, if not for 2.5
         */
        _name = new SerializedString(name.getSimpleName());
        _wrapperName = base._wrapperName;

        _member = base._member;
        _contextAnnotations = base._contextAnnotations;
        _declaredType = base._declaredType;
        _accessorMethod = base._accessorMethod;
        _field = base._field;
        _serializer = base._serializer;
        _nullSerializer = base._nullSerializer;
        // one more thing: copy internal settings, if any (since 1.7)
        if (base._internalSettings != null) {
            _internalSettings = new HashMap<Object,Object>(base._internalSettings);
        }
        _cfgSerializationType = base._cfgSerializationType;
        _dynamicSerializers = base._dynamicSerializers;
        _suppressNulls = base._suppressNulls;
        _suppressableValue = base._suppressableValue;
        _includeInViews = base._includeInViews;
        _typeSerializer = base._typeSerializer;
        _nonTrivialBaseType = base._nonTrivialBaseType;
        _metadata = base._metadata;
    }

    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {
        _name = name;
        _wrapperName = base._wrapperName;

        _member = base._member;
        _contextAnnotations = base._contextAnnotations;
        _declaredType = base._declaredType;
        _accessorMethod = base._accessorMethod;
        _field = base._field;
        _serializer = base._serializer;
        _nullSerializer = base._nullSerializer;
        if (base._internalSettings != null) {
            _internalSettings = new HashMap<Object,Object>(base._internalSettings);
        }
        _cfgSerializationType = base._cfgSerializationType;
        _dynamicSerializers = base._dynamicSerializers;
        _suppressNulls = base._suppressNulls;
        _suppressableValue = base._suppressableValue;
        _includeInViews = base._includeInViews;
        _typeSerializer = base._typeSerializer;
        _nonTrivialBaseType = base._nonTrivialBaseType;
        _metadata = base._metadata;
    }

    /**
     * @since 2.6
     */
    protected BeanPropertyWriter(BeanPropertyWriter base, TypeSerializer typeSer)
    {
        _name = base._name;
        _wrapperName = base._wrapperName;

        _member = base._member;
        _contextAnnotations = base._contextAnnotations;
        _declaredType = base._declaredType;
        _accessorMethod = base._accessorMethod;
        _field = base._field;
        _serializer = base._serializer;
        _nullSerializer = base._nullSerializer;
        _internalSettings = base._internalSettings; // safe, as per usage
        _cfgSerializationType = base._cfgSerializationType;
        _dynamicSerializers = base._dynamicSerializers;
        _suppressNulls = base._suppressNulls;
        _suppressableValue = base._suppressableValue;
        _includeInViews = base._includeInViews;
        _nonTrivialBaseType = base._nonTrivialBaseType;
        _metadata = base._metadata;

        _typeSerializer = typeSer;
    }
    
    public BeanPropertyWriter rename(NameTransformer transformer) {
        String newName = transformer.transform(_name.getValue());
        if (newName.equals(_name.toString())) {
            return this;
        }
        return new BeanPropertyWriter(this, PropertyName.construct(newName));
    }

}",Encapsulate Variable,"Encapsulate the ""_typeSerializer"" variable, and name it [keyword]:",FALSE,src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java,https://github.com/FasterXML/jackson-databind/commit/44dea1f292933192ea5287d9b3e14a7daaef3c0f
1109449,"public class StatusChangeEvent {
    private final InstanceInfo.InstanceStatus current;
    private final InstanceInfo.InstanceStatus previous;

    public StatusChangeEvent(InstanceInfo.InstanceStatus previous, InstanceInfo.InstanceStatus current) {
        this.current = current;
        this.previous = previous;
    }

    /**
     * Return the up current when the event was generated.
     * @return true if current is up or false for ALL other current values
     */
    public boolean isUp() {
        return this.current.equals(InstanceInfo.InstanceStatus.UP);
    }

    /**
     * @return The current at the time the event is generated.
     */
    public InstanceInfo.InstanceStatus getStatus() {
        return current;
    }

    /**
     * @return Return the client status immediately before the change
     */
    public InstanceInfo.InstanceStatus getPreviousStatus() {
        return previous;
    }

    @Override
    public String toString() {
        return ""StatusChangeEvent [current="" + current + "", previous=""
                + previous + ""]"";
    }

}

@FineGrainedLazySingleton
public class DiscoveryClient implements EurekaClient {
    private static final Logger logger = LoggerFactory.getLogger(DiscoveryClient.class);
    private static final DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();

    // Constants
    public static final int MAX_FOLLOWED_REDIRECTS = 10;
    public static final String HTTP_X_DISCOVERY_ALLOW_REDIRECT = ""X-Discovery-AllowRedirect"";

    private static final String VALUE_DELIMITER = "","";
    private static final String COMMA_STRING = VALUE_DELIMITER;
    private static final String DISCOVERY_APPID = ""DISCOVERY"";
    private static final String UNKNOWN = ""UNKNOWN"";

    private static final Pattern REDIRECT_PATH_REGEX = Pattern.compile(""(.*/v2/)apps(/.*)?$"");

    // Timers
    private static final String PREFIX = ""DiscoveryClient_"";
    private final com.netflix.servo.monitor.Timer GET_SERVICE_URLS_DNS_TIMER = Monitors
            .newTimer(PREFIX + ""GetServiceUrlsFromDNS"");
    private final com.netflix.servo.monitor.Timer REGISTER_TIMER = Monitors
            .newTimer(PREFIX + ""Register"");
    private final com.netflix.servo.monitor.Timer REFRESH_TIMER = Monitors
            .newTimer(PREFIX + ""Refresh"");
    private final com.netflix.servo.monitor.Timer REFRESH_DELTA_TIMER = Monitors
            .newTimer(PREFIX + ""RefreshDelta"");
    private final com.netflix.servo.monitor.Timer RENEW_TIMER = Monitors
            .newTimer(PREFIX + ""Renew"");
    private final com.netflix.servo.monitor.Timer CANCEL_TIMER = Monitors
            .newTimer(PREFIX + ""Cancel"");
    private final com.netflix.servo.monitor.Timer FETCH_REGISTRY_TIMER = Monitors
            .newTimer(PREFIX + ""FetchRegistry"");
    private final Counter SERVER_RETRY_COUNTER = Monitors.newCounter(PREFIX
            + ""Retry"");
    private final Counter ALL_SERVER_FAILURE_COUNT = Monitors.newCounter(PREFIX
            + ""Failed"");
    private final Counter REREGISTER_COUNTER = Monitors.newCounter(PREFIX
            + ""Reregister"");

    private final Provider<BackupRegistry> backupRegistryProvider;

    // instance variables
    private volatile HealthCheckHandler healthCheckHandler;
    private final Provider<HealthCheckHandler> healthCheckHandlerProvider;
    private final Provider<HealthCheckCallback> healthCheckCallbackProvider;
    private final AtomicReference<List<String>> eurekaServiceUrls = new AtomicReference<List<String>>();
    private final AtomicReference<Applications> localRegionApps = new AtomicReference<Applications>();
    private volatile Map<String, Applications> remoteRegionVsApps = new ConcurrentHashMap<String, Applications>();
    private final Lock fetchRegistryUpdateLock = new ReentrantLock();
    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version
    private final AtomicLong fetchRegistryGeneration;

    private final InstanceInfo instanceInfo;
    private String appPathIdentifier;
    private boolean isRegisteredWithDiscovery = false;
    private JerseyClient discoveryJerseyClient;
    private AtomicReference<String> lastQueryRedirect = new AtomicReference<String>();
    private AtomicReference<String> lastRegisterRedirect = new AtomicReference<String>();
    private ApacheHttpClient4 discoveryApacheClient;
    protected static EurekaClientConfig clientConfig;
    private final AtomicReference<String> remoteRegionsToFetch;
    private final InstanceRegionChecker instanceRegionChecker;
    private volatile InstanceInfo.InstanceStatus lastRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN;

    private ApplicationInfoManager.StatusChangeListener statusChangeListener;

    private enum Action {
        Register, Cancel, Renew, Refresh, Refresh_Delta
    }

    /**
     * A scheduler to be used for the following 3 tasks:
     * - updating service urls
     * - scheduling a TimedSuperVisorTask
     */
    private final ScheduledExecutorService scheduler;

    private InstanceInfoReplicator instanceInfoReplicator;

    // additional executors for executing hearbeat and cacheRefresh tasks
    private final ThreadPoolExecutor heartbeatExecutor;
    private final ThreadPoolExecutor cacheRefreshExecutor;

    private final EventBus eventBus;

    public static class DiscoveryClientOptionalArgs {
        @Inject(optional = true)
        private EventBus eventBus;

        @Inject(optional = true)
        private Provider<HealthCheckCallback> healthCheckCallbackProvider;

        @Inject(optional = true)
        private Provider<HealthCheckHandler> healthCheckHandlerProvider;
    }

    public DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config) {
        this(myInfo, config, null);
    }

    public DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, DiscoveryClientOptionalArgs args) {
        this(myInfo, config, args, new Provider<BackupRegistry>() {
            @Override
            public BackupRegistry get() {
                String backupRegistryClassName = clientConfig.getBackupRegistryImpl();
                if (null != backupRegistryClassName) {
                    try {
                        return (BackupRegistry) Class.forName(backupRegistryClassName).newInstance();
                    } catch (InstantiationException e) {
                        logger.error(""Error instantiating BackupRegistry."", e);
                    } catch (IllegalAccessException e) {
                        logger.error(""Error instantiating BackupRegistry."", e);
                    } catch (ClassNotFoundException e) {
                        logger.error(""Error instantiating BackupRegistry."", e);
                    }
                }

                logger.warn(""Using default backup registry implementation which does not do anything."");
                return new NotImplementedRegistryImpl();
            }
        });
    }

    @Override
    public Applications getApplications() {
        return localRegionApps.get();
    }

    @Override
    public Applications getApplicationsForARegion(@Nullable String region) {
        if (instanceRegionChecker.isLocalRegion(region)) {
            return localRegionApps.get();
        } else {
            return remoteRegionVsApps.get(region);
        }
    }

    public Set<String> getAllKnownRegions() {
        String localRegion = instanceRegionChecker.getLocalRegion();
        if (!remoteRegionVsApps.isEmpty()) {
            Set<String> regions = remoteRegionVsApps.keySet();
            Set<String> toReturn = new HashSet<String>(regions);
            toReturn.add(localRegion);
            return toReturn;
        } else {
            return Collections.singleton(localRegion);
        }
    }

    /*
     * (non-Javadoc)
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(java.lang.String)
     */
    @Override
    public List<InstanceInfo> getInstancesById(String id) {
        List<InstanceInfo> instancesList = new ArrayList<InstanceInfo>();
        for (Application app : this.getApplications()
                .getRegisteredApplications()) {
            InstanceInfo instanceInfo = app.getByInstanceId(id);
            if (instanceInfo != null) {
                instancesList.add(instanceInfo);
            }
        }
        return instancesList;
    }
}",Extract Superclass,Extract a superclass from StatusChangeEvent and name it [keyword]:,TRUE,eureka-client/src/main/java/com/netflix/discovery/DiscoveryEvent.java,https://github.com/Netflix/eureka/commit/1cacbe2ad700275bc575234ff2b32ee0d6493817
1157057,"class HistogramLogProcessorConfiguration {
    boolean verbose;
    String outputFile;

    public HistogramLogProcessorConfiguration(boolean verbose, String outputFile) {
        this.verbose = verbose;
        this.outputFile = outputFile;
    }

    public boolean isVerbose() {
        return verbose;
    }

    public String getOutputFile() {
        return outputFile;
    }
}

public class HistogramLogProcessor {
    private HistogramLogProcessorConfiguration config;

    public HistogramLogProcessor(HistogramLogProcessorConfiguration config) {
        this.config = config;
    }

    public HistogramLogProcessorConfiguration getConfig() {
        return config;
    }

    public void process() {
        if (config.isVerbose()) {
            System.out.println(""Processing log file, output: "" + config.getOutputFile());
        }
    }

    private void outputTimeRange(final PrintStream log, final String title) {
        log.format(Locale.US, ""#[%s between %.3f and"", title, config.rangeStartTimeSec);
        if (config.rangeEndTimeSec < Double.MAX_VALUE) {
            log.format("" %.3f"", config.rangeEndTimeSec);
        } else {
            log.format("" %s"", ""<Infinite>"");
        }
        log.format("" seconds (relative to StartTime)]\n"");
    }

    private void outputStartTime(final PrintStream log, final Double startTime) {
        log.format(Locale.US, ""#[StartTime: %.3f (seconds since epoch), %s]\n"",
                startTime, (new Date((long) (startTime * 1000))).toString());
    }

    /**
     * Run the log processor with the currently provided arguments.
     */
    @Override
    public void run() {
        PrintStream timeIntervalLog = null;
        PrintStream histogramPercentileLog = System.out;
        Double firstStartTime = 0.0;
        boolean timeIntervalLogLegendWritten = false;
        int lineNumber = 0;
        try {
            if (config.outputFileName != null) {
                try {
                    timeIntervalLog = new PrintStream(new FileOutputStream(config.outputFileName), false);
                    outputTimeRange(timeIntervalLog, ""Interval percentile log"");
                } catch (FileNotFoundException ex) {
                    System.err.println(""Failed to open output file "" + config.outputFileName);
                }
                String hgrmOutputFileName = config.outputFileName + "".hgrm"";
                try {
                    histogramPercentileLog = new PrintStream(new FileOutputStream(hgrmOutputFileName), false);
                    outputTimeRange(histogramPercentileLog, ""Overall percentile distribution"");
                } catch (FileNotFoundException ex) {
                    System.err.println(""Failed to open percentiles histogram output file "" + hgrmOutputFileName);
                }
            }

            final String logFormat;
            if (config.logFormatCsv) {
                logFormat = ""%.3f,%d,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f\n"";
            } else {
                logFormat = ""%4.3f: I:%d ( %7.3f %7.3f %7.3f ) T:%d ( %7.3f %7.3f %7.3f %7.3f %7.3f %7.3f )\n"";
            }


            EncodableHistogram intervalHistogram = logReader.nextIntervalHistogram(config.rangeStartTimeSec, config.rangeEndTimeSec);


            Histogram accumulatedRegularHistogram = null;
            DoubleHistogram accumulatedDoubleHistogram = null;

            if (intervalHistogram != null) {
                // Shape the accumulated histogram like the histograms in the log file (but clear their contents):
                if (intervalHistogram instanceof DoubleHistogram) {
                    accumulatedDoubleHistogram = ((DoubleHistogram) intervalHistogram).copy();
                    accumulatedDoubleHistogram.reset();
                    accumulatedDoubleHistogram.setAutoResize(true);
                } else {
                    accumulatedRegularHistogram = ((Histogram) intervalHistogram).copy();
                    accumulatedRegularHistogram.reset();
                    accumulatedRegularHistogram.setAutoResize(true);
                }
            }

            while (intervalHistogram != null) {
                if (intervalHistogram instanceof DoubleHistogram) {
                    if (accumulatedDoubleHistogram == null) {
                        throw new IllegalStateException(""Encountered a DoubleHistogram line in a log of Histograms."");
                    }
                    accumulatedDoubleHistogram.add((DoubleHistogram) intervalHistogram);
                } else {
                    if (accumulatedRegularHistogram == null) {
                        throw new IllegalStateException(""Encountered a Histogram line in a log of DoubleHistograms."");
                    }
                    accumulatedRegularHistogram.add((Histogram) intervalHistogram);
                }

                if ((firstStartTime == 0.0) && (logReader.getStartTimeSec() != 0.0)) {
                    firstStartTime = logReader.getStartTimeSec();

                    outputStartTime(histogramPercentileLog, firstStartTime);

                    if (timeIntervalLog != null) {
                        outputStartTime(timeIntervalLog, firstStartTime);
                    }
                }

                if (timeIntervalLog != null) {
                    if (!timeIntervalLogLegendWritten) {
                        timeIntervalLogLegendWritten = true;
                        if (config.logFormatCsv) {
                            timeIntervalLog.println(""\""Timestamp\"",\""Int_Count\"",\""Int_50%\"",\""Int_90%\"",\""Int_Max\"",\""Total_Count\"","" +
                                    ""\""Total_50%\"",\""Total_90%\"",\""Total_99%\"",\""Total_99.9%\"",\""Total_99.99%\"",\""Total_Max\"""");
                        } else {
                            timeIntervalLog.println(""Time: IntervalPercentiles:count ( 50% 90% Max ) TotalPercentiles:count ( 50% 90% 99% 99.9% 99.99% Max )"");
                        }
                    }

                    if (intervalHistogram instanceof DoubleHistogram) {
                        timeIntervalLog.format(Locale.US, logFormat,
                                ((intervalHistogram.getEndTimeStamp() / 1000.0) - logReader.getStartTimeSec()),
                                // values recorded during the last reporting interval
                                ((DoubleHistogram) intervalHistogram).getTotalCount(),
                                ((DoubleHistogram) intervalHistogram).getValueAtPercentile(50.0) / config.outputValueUnitRatio,
                                ((DoubleHistogram) intervalHistogram).getValueAtPercentile(90.0) / config.outputValueUnitRatio,
                                ((DoubleHistogram) intervalHistogram).getMaxValue() / config.outputValueUnitRatio,
                                // values recorded from the beginning until now
                                accumulatedDoubleHistogram.getTotalCount(),
                                accumulatedDoubleHistogram.getValueAtPercentile(50.0) / config.outputValueUnitRatio,
                                accumulatedDoubleHistogram.getValueAtPercentile(90.0) / config.outputValueUnitRatio,
                                accumulatedDoubleHistogram.getValueAtPercentile(99.0) / config.outputValueUnitRatio,
                                accumulatedDoubleHistogram.getValueAtPercentile(99.9) / config.outputValueUnitRatio,
                                accumulatedDoubleHistogram.getValueAtPercentile(99.99) / config.outputValueUnitRatio,
                                accumulatedDoubleHistogram.getMaxValue() / config.outputValueUnitRatio
                        );
                    } else {
                        timeIntervalLog.format(Locale.US, logFormat,
                                ((intervalHistogram.getEndTimeStamp() / 1000.0) - logReader.getStartTimeSec()),
                                // values recorded during the last reporting interval
                                ((Histogram) intervalHistogram).getTotalCount(),
                                ((Histogram) intervalHistogram).getValueAtPercentile(50.0) / config.outputValueUnitRatio,
                                ((Histogram) intervalHistogram).getValueAtPercentile(90.0) / config.outputValueUnitRatio,
                                ((Histogram) intervalHistogram).getMaxValue() / config.outputValueUnitRatio,
                                // values recorded from the beginning until now
                                accumulatedRegularHistogram.getTotalCount(),
                                accumulatedRegularHistogram.getValueAtPercentile(50.0) / config.outputValueUnitRatio,
                                accumulatedRegularHistogram.getValueAtPercentile(90.0) / config.outputValueUnitRatio,
                                accumulatedRegularHistogram.getValueAtPercentile(99.0) / config.outputValueUnitRatio,
                                accumulatedRegularHistogram.getValueAtPercentile(99.9) / config.outputValueUnitRatio,
                                accumulatedRegularHistogram.getValueAtPercentile(99.99) / config.outputValueUnitRatio,
                                accumulatedRegularHistogram.getMaxValue() / config.outputValueUnitRatio
                        );
                    }
                }

                lineNumber++;
                // Read and accumulate the next line:
                try {
                    intervalHistogram = logReader.nextIntervalHistogram(config.rangeStartTimeSec, config.rangeEndTimeSec);
                } catch (RuntimeException ex) {
                    System.err.println(""Log file parsing error at line number "" + lineNumber +
                            "": line appears to be malformed."");
                    if (config.verbose) {
                        throw ex;
                    } else {
                        System.exit(1);
                    }
                }
            }

            if (accumulatedDoubleHistogram != null) {
                accumulatedDoubleHistogram.outputPercentileDistribution(histogramPercentileLog,
                        config.percentilesOutputTicksPerHalf, config.outputValueUnitRatio, config.logFormatCsv);
            } else {
                if (accumulatedRegularHistogram == null) {
                    // If there were no histograms in the log file, we still need an empty histogram for the
                    // one line output (shape/range doesn't matter because it is empty):
                    accumulatedRegularHistogram = new Histogram(1000000L, 2);
                }
                accumulatedRegularHistogram.outputPercentileDistribution(histogramPercentileLog,
                        config.percentilesOutputTicksPerHalf, config.outputValueUnitRatio, config.logFormatCsv);
            }
        } finally {
            if (config.outputFileName != null) {
                timeIntervalLog.close();
                histogramPercentileLog.close();
            }
        }
    }
}",Hide Delegate,"Refactor the following class to hide delegation so that clients don’t call getConfig() directly. Create a new class to hide the delegation of HistogramLogProcessorConfiguration, and name it [keyword]:",FALSE,src/main/java/org/HdrHistogram/HistogramLogProcessor.java,https://github.com/HdrHistogram/HdrHistogram/commit/0e65ac4da70c6ca5c67bb8418e67db914218042f
1153146,"package clojure.lang;

import java.util.*;

public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted {

    private final Object _first;
    private final IPersistentList _rest;
    private final int _count;

    public PersistentList(Object first, IPersistentList rest) {
        this._first = first;
        this._rest = rest;
        this._count = (rest == null ? 0 : rest.count()) + 1;
    }

    public Object first() {
        if (_count == 0) return null;
        return _first;
    }

    public ISeq next() {
        if (_count <= 1) return null;
        return (ISeq) _rest;
    }

    public IPersistentList pop() {
        if (_count == 0) throw new IllegalStateException(""Can't pop empty list"");
        return _rest;
    }

    public int count() {
        return _count;
    }

    public boolean isEmpty() {
        return _count == 0;
    }

    static public class Primordial extends RestFn{
        final public int getRequiredArity(){
                return 0;
        }

        final protected Object doInvoke(Object args) {
                if(args instanceof ArraySeq)
                        {
                        Object[] argsarray = ((ArraySeq) args).array;
                        IPersistentList ret = EMPTY;
                        for(int i = argsarray.length - 1; i >= ((ArraySeq)args).i; --i)
                                ret = (IPersistentList) ret.cons(argsarray[i]);
                        return ret;
                        }
                LinkedList list = new LinkedList();
                for(ISeq s = RT.seq(args); s != null; s = s.next())
                        list.add(s.first());
                return create(list);
        }

        static public Object invokeStatic(ISeq args) {
                if(args instanceof ArraySeq)
                        {
                        Object[] argsarray = ((ArraySeq) args).array;
                        IPersistentList ret = EMPTY;
                        for(int i = argsarray.length - 1; i >= 0; --i)
                                ret = (IPersistentList) ret.cons(argsarray[i]);
                        return ret;
                        }
                LinkedList list = new LinkedList();
                for(ISeq s = RT.seq(args); s != null; s = s.next())
                        list.add(s.first());
                return create(list);
        }

        public IObj withMeta(IPersistentMap meta){
                throw new UnsupportedOperationException();
        }

        public IPersistentMap meta(){
                return null;
        }

    public static IFn creator = new Primordial();

    final public static EmptyList EMPTY = new EmptyList(null);

    public PersistentList(Object first){
        this._first = first;
        this._rest = null;

        this._count = 1;
    }

    PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count){
        super(meta);
        this._first = _first;
        this._rest = _rest;
        this._count = _count;
    }

    public static IPersistentList create(List init){
        IPersistentList ret = EMPTY;
        for(ListIterator i = init.listIterator(init.size()); i.hasPrevious();)
            {
            ret = (IPersistentList) ret.cons(i.previous());
            }
        return ret;
    }

    public Object first(){
        return _first;
    }

    public ISeq next(){
        if(_count == 1)
            return null;
        return (ISeq) _rest;
    }

    public Object peek(){
        return first();
    }

    public IPersistentList pop(){
        if(_rest == null)
            return EMPTY.withMeta(_meta);
        return _rest;
    }

    public int count(){
        return _count;
    }

    public PersistentList cons(Object o){
        return new PersistentList(meta(), o, this, _count + 1);
    }

    public IPersistentCollection empty(){
        return EMPTY.withMeta(meta());
    }

    public PersistentList withMeta(IPersistentMap meta){
        if(meta != _meta)
            return new PersistentList(meta, _first, _rest, _count);
        return this;
    }

    public Object reduce(IFn f) {
        Object ret = first();
        for(ISeq s = next(); s != null; s = s.next()) {
            ret = f.invoke(ret, s.first());
            if (RT.isReduced(ret)) return ((IDeref)ret).deref();;
        }
        return ret;
    }

    public Object reduce(IFn f, Object start) {
        Object ret = f.invoke(start, first());
        for(ISeq s = next(); s != null; s = s.next()) {
            if (RT.isReduced(ret)) return ((IDeref)ret).deref();
            ret = f.invoke(ret, s.first());
        }
        if (RT.isReduced(ret)) return ((IDeref)ret).deref();
        return ret;
    }


    static class EmptyList extends Obj implements IPersistentList, List, ISeq, Counted, IHashEq{
    static final int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST);

    public int hashCode(){
        return 1;
    }

    public int hasheq(){
        return hasheq;
    }

    public boolean equals(Object o) {
        return (o instanceof Sequential || o instanceof List) && RT.seq(o) == null;
    }

    public boolean equiv(Object o){
        return equals(o);
    }
    
    EmptyList(IPersistentMap meta){
        super(meta);
    }

        public Object first() {
            return null;
        }

        public ISeq next() {
            return null;
        }

        public ISeq more() {
            return this;
        }

        public PersistentList cons(Object o){
        return new PersistentList(meta(), o, null, 1);
    }
}",Introduce Special Case,Create a new class to handle empty list behavior and name it [keyword]:,FALSE,src/jvm/clojure/lang/PersistentList.java,https://github.com/clojure/clojure/commit/309c03055b06525c275b278542c881019424760e
1150188,"public class IncomingTcpConnection extends Thread implements Closeable
{
    private static final Logger logger = LoggerFactory.getLogger(IncomingTcpConnection.class);

    private final int version;
    private final boolean compressed;
    private final Socket socket;
    private final Set<Closeable> group;
    public InetAddress from;

    public IncomingTcpConnection(int version, boolean compressed, Socket socket, Set<Closeable> group)
    {
        super(""MessagingService-Incoming-"" + socket.getInetAddress());
        this.version = version;
        this.compressed = compressed;
        this.socket = socket;
        this.group = group;
        if (DatabaseDescriptor.getInternodeRecvBufferSize() != null)
        {
            try
            {
                this.socket.setReceiveBufferSize(DatabaseDescriptor.getInternodeRecvBufferSize());
            }
            catch (SocketException se)
            {
                logger.warn(""Failed to set receive buffer size on internode socket."", se);
            }
        }
    }

    private InetAddress receiveMessage(DataInputStream input, int version) throws IOException
    {
        int id;
        if (version < MessagingService.VERSION_20)
            id = Integer.parseInt(input.readUTF());
        else
            id = input.readInt();

        long timestamp = System.currentTimeMillis();
        boolean isCrossNodeTimestamp = false;

        int partial = input.readInt();
        if (DatabaseDescriptor.hasCrossNodeTimeout())
        {
            long crossNodeTimestamp = (timestamp & 0xFFFFFFFF00000000L) 
                                    | (((partial & 0xFFFFFFFFL) << 2) >> 2);
            isCrossNodeTimestamp = (timestamp != crossNodeTimestamp);
            timestamp = crossNodeTimestamp;
        }

        MessageIn message = MessageIn.read(input, version, id);
        if (message == null)
        {
            // callback expired; nothing to do
            return null;
        }

        if (version <= MessagingService.current_version)
        {
            MessagingService.instance().receive(message, id, timestamp, isCrossNodeTimestamp);
        }
        else
        {
            logger.debug(""Received connection from newer protocol version {}. Ignoring message"", version);
        }
        return message.from;
    }

    /**
     * A new connection will either stream or message for its entire lifetime: because streaming
     * bypasses the InputStream implementations to use sendFile, we cannot begin buffering until
     * we've determined the type of the connection.
     */
    @Override
    public void run()
    {
        try
        {
            if (version < MessagingService.VERSION_12)
                throw new UnsupportedOperationException(""Unable to read obsolete message version "" + version + ""; the earliest version supported is 1.2.0"");

            receiveMessages();
        }
        catch (EOFException e)
        {
            logger.trace(""eof reading from socket; closing"", e);
            // connection will be reset so no need to throw an exception.
        }
        catch (UnknownColumnFamilyException e)
        {
            logger.warn(""UnknownColumnFamilyException reading from socket; closing"", e);
        }
        catch (IOException e)
        {
            logger.debug(""IOException reading from socket; closing"", e);
        }
        finally
        {
            close();
        }
    }
    
    @Override
    public void close()
    {
        try
        {
            if (!socket.isClosed())
            {
                socket.close();
            }
        }
        catch (IOException e)
        {
            logger.debug(""Error closing socket"", e);
        }
        finally
        {
            group.remove(this);
        }
    }

    private void receiveMessages() throws IOException
    {
        // handshake (true) endpoint versions
        DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        // if this version is < the MS version the other node is trying
        // to connect with, the other node will disconnect
        out.writeInt(MessagingService.current_version);
        out.flush();
        DataInputStream in = new DataInputStream(socket.getInputStream());
        int maxVersion = in.readInt();
        // outbound side will reconnect if necessary to upgrade version
        assert version <= MessagingService.current_version;
        from = CompactEndpointSerializationHelper.deserialize(in);
        // record the (true) version of the endpoint
        MessagingService.instance().setVersion(from, maxVersion);
        logger.debug(""Set version for {} to {} (will use {})"", from, maxVersion, MessagingService.instance().getVersion(from));

        if (compressed)
        {
            logger.debug(""Upgrading incoming connection to be compressed"");
            in = new DataInputStream(new SnappyInputStream(socket.getInputStream()));
        }
        else
        {
            in = new DataInputStream(new BufferedInputStream(socket.getInputStream(), 4096));
        }

        while (true)
        {
            MessagingService.validateMagic(in.readInt());
            receiveMessage(in, version);
        }
    }
}",Parameterize Function,Create a new function and name it [keyword] to parameterize the function for reading message IDs based on different protocol versions:,FALSE,src/java/org/apache/cassandra/net/IncomingTcpConnection.java,https://github.com/apache/cassandra/commit/573a1d115b86abbe3fb53ff930464d7d8fd95600
1148739,"class SCMBinder extends FlowDefinition {

    private static final Map<CpsFlowExecution,SCM> scms = Collections.synchronizedMap(new WeakHashMap<CpsFlowExecution,SCM>());

    // Note that this cannot be a GlobalVariable, since that must always be set.
    @Extension public static class Decorator extends GroovyShellDecorator {

        @Override public void configureShell(CpsFlowExecution context, GroovyShell shell) {
            if (context != null) {
                SCM scm = scms.remove(context);
                if (scm != null) {
                    shell.setVariable(""scm"", scm);
                }
            }
        }

    }

    @Override public FlowExecution create(FlowExecutionOwner handle, TaskListener listener, List<? extends Action> actions) throws Exception {
        Queue.Executable exec = handle.getExecutable();
        if (!(exec instanceof WorkflowRun)) {
            throw new IllegalStateException(""inappropriate context"");
        }
        WorkflowJob job = ((WorkflowRun) exec).getParent();
        BranchJobProperty property = job.getProperty(BranchJobProperty.class);
        if (property == null) {
            throw new IllegalStateException(""inappropriate context"");
        }
        Branch branch = property.getBranch();
        ItemGroup<?> parent = job.getParent();
        if (!(parent instanceof WorkflowMultiBranchProject)) {
            throw new IllegalStateException(""inappropriate context"");
        }
        SCMSource scmSource = ((WorkflowMultiBranchProject) parent).getSCMSource(branch.getSourceId());
        if (scmSource == null) {
            throw new IllegalStateException(branch.getSourceId() + "" not found"");
        }
        SCMHead head = branch.getHead();
        SCMRevision tip = scmSource.fetch(SCMHeadObserver.select(head), listener).result();
        if (tip == null) {
            throw new IllegalStateException(""could not find branch tip on "" + head);
        }
        SCM scm = scmSource.build(head, tip);
        // Fallback if one is needed: scm = branch.getScm()
        CpsFlowExecution execution = new CpsScmFlowDefinition(scm, WorkflowMultiBranchProject.SCRIPT).create(handle, listener, actions);
        scms.put(execution, scm); // stash for later
        return execution;
    }


    // Not registered as an @Extension, but in case someone calls it:
    @Override public FlowDefinitionDescriptor getDescriptor() {
        return new FlowDefinitionDescriptor() {
            @Override public String getDisplayName() {
                return ""SCMBinder""; // should not be used in UI
            }
        };
    }

    @Extension public static class Pickler extends SingleTypedPickleFactory<SCM> {

        @Override protected Pickle pickle(SCM scm) {
            return new XStreamPickle(scm);
        }

    }


}

public class WorkflowBranchProjectFactory extends BranchProjectFactory<WorkflowJob,WorkflowRun> {
    
    private static final Logger LOGGER = Logger.getLogger(WorkflowBranchProjectFactory.class.getName());

    @DataBoundConstructor public WorkflowBranchProjectFactory() {}

    @Override public WorkflowJob newInstance(Branch branch) {
        WorkflowJob job = new WorkflowJob((WorkflowMultiBranchProject) getOwner(), branch.getName());
        job.setDefinition(new SCMBinder());
        setBranch(job, branch);
        return job;
    }

    @Override public Branch getBranch(WorkflowJob project) {
        return project.getProperty(BranchJobProperty.class).getBranch();
    }

    @Override public WorkflowJob setBranch(WorkflowJob project, Branch branch) {
        BranchJobProperty property = project.getProperty(BranchJobProperty.class);
        try {
            if (property == null) {
                property = new BranchJobProperty();
                property.setBranch(branch);
                project.addProperty(property);
            } else if (!property.getBranch().equals(branch)) {
                property.setBranch(branch);
                project.save();
            }
        } catch (IOException x) {
            LOGGER.log(Level.WARNING, null, x);
        }
        return project;
    }

    @Override public boolean isProject(Item item) {
        return item instanceof WorkflowJob && ((WorkflowJob) item).getProperty(BranchJobProperty.class) != null;
    }

    @Extension public static class DescriptorImpl extends BranchProjectFactoryDescriptor {

        @Override public String getDisplayName() {
            return ""Fixed configuration"";
        }

        @SuppressWarnings(""rawtypes"") // TODO fix super class
        @Override public boolean isApplicable(Class<? extends MultiBranchProject> clazz) {
            return WorkflowMultiBranchProject.class.isAssignableFrom(clazz);
        }

    }

}

@SuppressWarnings({""unchecked"", ""rawtypes""}) // core’s fault
public class WorkflowMultiBranchProject extends MultiBranchProject<WorkflowJob,WorkflowRun> {

    static final String SCRIPT = ""jenkins.groovy"";

    public WorkflowMultiBranchProject(ItemGroup parent, String name) {
        super(parent, name);
    }

    @Override protected BranchProjectFactory<WorkflowJob,WorkflowRun> newProjectFactory() {
        return new WorkflowBranchProjectFactory();
    }

    @Override public SCMSourceCriteria getSCMSourceCriteria(SCMSource source) {
        return new SCMSourceCriteria() {
            @Override public boolean isHead(SCMSourceCriteria.Probe probe, TaskListener listener) throws IOException {
                return probe.exists(SCRIPT);
            }
        };
    }

    // TODO unnecessary to override once branch-api on 1.592+
    @Override public Authentication getDefaultAuthentication(Queue.Item item) {
        return getDefaultAuthentication();
    }

    @Extension public static class DescriptorImpl extends MultiBranchProjectDescriptor {

        @Override public String getDisplayName() {
            return ""Multibranch Workflow"";
        }

        @Override public TopLevelItem newInstance(ItemGroup parent, String name) {
            return new WorkflowMultiBranchProject(parent, name);
        }

        @Override public List<SCMDescriptor<?>> getSCMDescriptors() {
            // TODO this is a problem. We need to select only those compatible with Workflow.
            // Yet SCMDescriptor.isApplicable requires an actual Job, whereas we can only pass WorkflowJob.class!
            // Can we create a dummy WorkflowJob instance?
            return SCM.all();
        }

    }

}",Remove Flag Argument,"Remove the flag argument by splitting the null-check behavior into separate methods and name them [keyword]A, [keyword]B:",FALSE,multibranch/src/main/java/org/jenkinsci/plugins/workflow/multibranch/SCMBinder.java,https://github.com/jenkinsci/workflow-plugin/commit/d0e374ce8ecb687b4dc046d1edea9e52da17706f
1147348,"private void reportHistogram(String name, Histogram histogram, long timestamp) throws IOException {
        final Snapshot snapshot = histogram.getSnapshot();
        graphite.send(prefix(name, ""count""), format(histogram.getCount()), timestamp);
        graphite.send(prefix(name, ""max""), format(snapshot.getMax()), timestamp);
        graphite.send(prefix(name, ""mean""), format(snapshot.getMean()), timestamp);
        graphite.send(prefix(name, ""min""), format(snapshot.getMin()), timestamp);
        graphite.send(prefix(name, ""stddev""), format(snapshot.getStdDev()), timestamp);
        graphite.send(prefix(name, ""p50""), format(snapshot.getMedian()), timestamp);
        graphite.send(prefix(name, ""p75""), format(snapshot.get75thPercentile()), timestamp);
        graphite.send(prefix(name, ""p95""), format(snapshot.get95thPercentile()), timestamp);
        graphite.send(prefix(name, ""p98""), format(snapshot.get98thPercentile()), timestamp);
        graphite.send(prefix(name, ""p99""), format(snapshot.get99thPercentile()), timestamp);
        graphite.send(prefix(name, ""p999""), format(snapshot.get999thPercentile()), timestamp);
}

private void reportCounter(String name, Counter counter, long timestamp) throws IOException {
        graphite.send(prefix(name, ""count""), format(counter.getCount()), timestamp);
}

private void reportGauge(String name, Gauge gauge, long timestamp) throws IOException {
        final String value = format(gauge.getValue());
        if (value != null) {
                graphite.send(prefix(name), value, timestamp);
        }
}

private String format(Object o) {
        if (o instanceof Float) {
                return format(((Float) o).doubleValue());
        } else if (o instanceof Double) {
                return format(((Double) o).doubleValue());
        } else if (o instanceof Byte) {
                return format(((Byte) o).longValue());
        } else if (o instanceof Short) {
                return format(((Short) o).longValue());
        } else if (o instanceof Integer) {
                return format(((Integer) o).longValue());
        } else if (o instanceof Long) {
                return format(((Long) o).longValue());
        }
        return null;
}

private void reportCounter(String name, Counter counter, long timestamp) throws IOException {
	graphite.send(prefix(name, ""count""), format(counter.getCount()), timestamp);
}

private void reportGauge(String name, Gauge gauge, long timestamp) throws IOException {
	final String value = format(gauge.getValue());
	if (value != null) {
		graphite.send(prefix(name), value, timestamp);
	}
}

private String prefix(String... components) {
	return MetricRegistry.name(prefix, components);
}

private String format(long n) {
	return Long.toString(n);
}

private String format(double v) {
	// the Carbon plaintext format is pretty underspecified, but it seems like it just wants
	// US-formatted digits
	return String.format(Locale.US, ""%2.2f"", v);
}



private GraphiteReporter(MetricRegistry registry,
							GraphiteSender graphite,
							Clock clock,
							String prefix,
							TimeUnit rateUnit,
							TimeUnit durationUnit,
							MetricFilter filter) {
	super(registry, ""graphite-reporter"", filter, rateUnit, durationUnit);
	this.graphite = graphite;
	this.clock = clock;
	this.prefix = prefix;
}

@Override
public void report(SortedMap<String, Gauge> gauges,
					SortedMap<String, Counter> counters,
					SortedMap<String, Histogram> histograms,
					SortedMap<String, Meter> meters,
					SortedMap<String, Timer> timers) {
	final long timestamp = clock.getTime() / 1000;

	// oh it'd be lovely to use Java 7 here
	try {
		if (!graphite.isConnected()) {
				graphite.connect();
		}

		for (Map.Entry<String, Gauge> entry : gauges.entrySet()) {
			reportGauge(entry.getKey(), entry.getValue(), timestamp);
		}

		for (Map.Entry<String, Counter> entry : counters.entrySet()) {
			reportCounter(entry.getKey(), entry.getValue(), timestamp);
		}

		for (Map.Entry<String, Histogram> entry : histograms.entrySet()) {
			reportHistogram(entry.getKey(), entry.getValue(), timestamp);
		}

		for (Map.Entry<String, Meter> entry : meters.entrySet()) {
			reportMetered(entry.getKey(), entry.getValue(), timestamp);
		}

		for (Map.Entry<String, Timer> entry : timers.entrySet()) {
			reportTimer(entry.getKey(), entry.getValue(), timestamp);
		}

		graphite.flush();
	} catch (Throwable t) {
		LOGGER.warn(""Unable to report to Graphite"", graphite, t);
		closeGraphiteConnection();
	}
}

private void closeGraphiteConnection() {
	try {
		graphite.close();
	} catch (IOException e) {
		LOGGER.warn(""Error closing Graphite"", graphite, e);
	}
}

@Override
public void stop() {
	try {
		super.stop();
	} finally {
		try {
			graphite.close();
		} catch (IOException e) {
			LOGGER.debug(""Error disconnecting from Graphite"", graphite, e);
		}
	}
}

private void reportTimer(String name, Timer timer, long timestamp) throws IOException {
	final Snapshot snapshot = timer.getSnapshot();

	graphite.send(prefix(name, ""max""), format(convertDuration(snapshot.getMax())), timestamp);
	graphite.send(prefix(name, ""mean""), format(convertDuration(snapshot.getMean())), timestamp);
	graphite.send(prefix(name, ""min""), format(convertDuration(snapshot.getMin())), timestamp);
	graphite.send(prefix(name, ""stddev""),
					format(convertDuration(snapshot.getStdDev())),
					timestamp);
	graphite.send(prefix(name, ""p50""),
					format(convertDuration(snapshot.getMedian())),
					timestamp);
	graphite.send(prefix(name, ""p75""),
					format(convertDuration(snapshot.get75thPercentile())),
					timestamp);
	graphite.send(prefix(name, ""p95""),
					format(convertDuration(snapshot.get95thPercentile())),
					timestamp);
	graphite.send(prefix(name, ""p98""),
					format(convertDuration(snapshot.get98thPercentile())),
					timestamp);
	graphite.send(prefix(name, ""p99""),
					format(convertDuration(snapshot.get99thPercentile())),
					timestamp);
	graphite.send(prefix(name, ""p999""),
					format(convertDuration(snapshot.get999thPercentile())),
					timestamp);

	reportMetered(name, timer, timestamp);
}

private void reportMetered(String name, Metered meter, long timestamp) throws IOException {
	graphite.send(prefix(name, ""count""), format(meter.getCount()), timestamp);
	graphite.send(prefix(name, ""m1_rate""),
					format(convertRate(meter.getOneMinuteRate())),
					timestamp);
	graphite.send(prefix(name, ""m5_rate""),
					format(convertRate(meter.getFiveMinuteRate())),
					timestamp);
	graphite.send(prefix(name, ""m15_rate""),
					format(convertRate(meter.getFifteenMinuteRate())),
					timestamp);
	graphite.send(prefix(name, ""mean_rate""),
					format(convertRate(meter.getMeanRate())),
					timestamp);
}",Replace Command with Function,Replace the repetitive graphite.send commands with a new function and name it [keyword]:,FALSE,metrics-graphite/src/main/java/com/codahale/metrics/graphite/GraphiteReporter.java,https://github.com/dropwizard/metrics/commit/4c6ab3d77cc67c7a91155d884077520dcf1509c6
1144626,"public class WCWidth {

    public static int wcwidth(int ucs)
    {

        /* test for 8-bit control characters */
        if (ucs == 0)
            return 0;
        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
            return -1;

        /* binary search in table of non-spacing characters */
        if (bisearch(ucs, combining, combining.length - 1))
            return 0;

        /* if we arrive here, ucs is not a combining or C0/C1 control character */
        return 1 +
                ((ucs >= 0x1100 &&
                        (ucs <= 0x115f ||                           /* Hangul Jamo init. consonants */
                                ucs == 0x2329 || ucs == 0x232a ||
                                (ucs >= 0x2e80 && ucs <= 0xa4cf &&
                                        ucs != 0x303f) ||           /* CJK ... Yi */
                                (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
                                (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
                                (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
                                (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
                                (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
                                (ucs >= 0xffe0 && ucs <= 0xffe6) ||
                                (ucs >= 0x20000 && ucs <= 0x2fffd) ||
                                (ucs >= 0x30000 && ucs <= 0x3fffd))) ? 1 : 0);
    }

    /* sorted list of non-overlapping intervals of non-spacing characters */
    /* generated by ""uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c"" */
    static Interval[] combining = {
            new Interval( 0x0300, 0x036F ), new Interval( 0x0483, 0x0486 ), new Interval( 0x0488, 0x0489 ),
            new Interval( 0x0591, 0x05BD ), new Interval( 0x05BF, 0x05BF ), new Interval( 0x05C1, 0x05C2 ),
            new Interval( 0x05C4, 0x05C5 ), new Interval( 0x05C7, 0x05C7 ), new Interval( 0x0600, 0x0603 ),
            new Interval( 0x0610, 0x0615 ), new Interval( 0x064B, 0x065E ), new Interval( 0x0670, 0x0670 ),
            new Interval( 0x06D6, 0x06E4 ), new Interval( 0x06E7, 0x06E8 ), new Interval( 0x06EA, 0x06ED ),
            new Interval( 0x070F, 0x070F ), new Interval( 0x0711, 0x0711 ), new Interval( 0x0730, 0x074A ),
            new Interval( 0x07A6, 0x07B0 ), new Interval( 0x07EB, 0x07F3 ), new Interval( 0x0901, 0x0902 ),
            new Interval( 0x093C, 0x093C ), new Interval( 0x0941, 0x0948 ), new Interval( 0x094D, 0x094D ),
            new Interval( 0x0951, 0x0954 ), new Interval( 0x0962, 0x0963 ), new Interval( 0x0981, 0x0981 ),
            new Interval( 0x09BC, 0x09BC ), new Interval( 0x09C1, 0x09C4 ), new Interval( 0x09CD, 0x09CD ),
            new Interval( 0x09E2, 0x09E3 ), new Interval( 0x0A01, 0x0A02 ), new Interval( 0x0A3C, 0x0A3C ),
            new Interval( 0x0A41, 0x0A42 ), new Interval( 0x0A47, 0x0A48 ), new Interval( 0x0A4B, 0x0A4D ),
            new Interval( 0x0A70, 0x0A71 ), new Interval( 0x0A81, 0x0A82 ), new Interval( 0x0ABC, 0x0ABC ),
            new Interval( 0x0AC1, 0x0AC5 ), new Interval( 0x0AC7, 0x0AC8 ), new Interval( 0x0ACD, 0x0ACD ),
            new Interval( 0x0AE2, 0x0AE3 ), new Interval( 0x0B01, 0x0B01 ), new Interval( 0x0B3C, 0x0B3C ),
            new Interval( 0x0B3F, 0x0B3F ), new Interval( 0x0B41, 0x0B43 ), new Interval( 0x0B4D, 0x0B4D ),
            new Interval( 0x0B56, 0x0B56 ), new Interval( 0x0B82, 0x0B82 ), new Interval( 0x0BC0, 0x0BC0 ),
            new Interval( 0x0BCD, 0x0BCD ), new Interval( 0x0C3E, 0x0C40 ), new Interval( 0x0C46, 0x0C48 ),
            new Interval( 0x0C4A, 0x0C4D ), new Interval( 0x0C55, 0x0C56 ), new Interval( 0x0CBC, 0x0CBC ),
            new Interval( 0x0CBF, 0x0CBF ), new Interval( 0x0CC6, 0x0CC6 ), new Interval( 0x0CCC, 0x0CCD ),
            new Interval( 0x0CE2, 0x0CE3 ), new Interval( 0x0D41, 0x0D43 ), new Interval( 0x0D4D, 0x0D4D ),
            new Interval( 0x0DCA, 0x0DCA ), new Interval( 0x0DD2, 0x0DD4 ), new Interval( 0x0DD6, 0x0DD6 ),
            new Interval( 0x0E31, 0x0E31 ), new Interval( 0x0E34, 0x0E3A ), new Interval( 0x0E47, 0x0E4E ),
            new Interval( 0x0EB1, 0x0EB1 ), new Interval( 0x0EB4, 0x0EB9 ), new Interval( 0x0EBB, 0x0EBC ),
            new Interval( 0x0EC8, 0x0ECD ), new Interval( 0x0F18, 0x0F19 ), new Interval( 0x0F35, 0x0F35 ),
            new Interval( 0x0F37, 0x0F37 ), new Interval( 0x0F39, 0x0F39 ), new Interval( 0x0F71, 0x0F7E ),
            new Interval( 0x0F80, 0x0F84 ), new Interval( 0x0F86, 0x0F87 ), new Interval( 0x0F90, 0x0F97 ),
            new Interval( 0x0F99, 0x0FBC ), new Interval( 0x0FC6, 0x0FC6 ), new Interval( 0x102D, 0x1030 ),
            new Interval( 0x1032, 0x1032 ), new Interval( 0x1036, 0x1037 ), new Interval( 0x1039, 0x1039 ),
            new Interval( 0x1058, 0x1059 ), new Interval( 0x1160, 0x11FF ), new Interval( 0x135F, 0x135F ),
            new Interval( 0x1712, 0x1714 ), new Interval( 0x1732, 0x1734 ), new Interval( 0x1752, 0x1753 ),
            new Interval( 0x1772, 0x1773 ), new Interval( 0x17B4, 0x17B5 ), new Interval( 0x17B7, 0x17BD ),
            new Interval( 0x17C6, 0x17C6 ), new Interval( 0x17C9, 0x17D3 ), new Interval( 0x17DD, 0x17DD ),
            new Interval( 0x180B, 0x180D ), new Interval( 0x18A9, 0x18A9 ), new Interval( 0x1920, 0x1922 ),
            new Interval( 0x1927, 0x1928 ), new Interval( 0x1932, 0x1932 ), new Interval( 0x1939, 0x193B ),
            new Interval( 0x1A17, 0x1A18 ), new Interval( 0x1B00, 0x1B03 ), new Interval( 0x1B34, 0x1B34 ),
            new Interval( 0x1B36, 0x1B3A ), new Interval( 0x1B3C, 0x1B3C ), new Interval( 0x1B42, 0x1B42 ),
            new Interval( 0x1B6B, 0x1B73 ), new Interval( 0x1DC0, 0x1DCA ), new Interval( 0x1DFE, 0x1DFF ),
            new Interval( 0x200B, 0x200F ), new Interval( 0x202A, 0x202E ), new Interval( 0x2060, 0x2063 ),
            new Interval( 0x206A, 0x206F ), new Interval( 0x20D0, 0x20EF ), new Interval( 0x302A, 0x302F ),
            new Interval( 0x3099, 0x309A ), new Interval( 0xA806, 0xA806 ), new Interval( 0xA80B, 0xA80B ),
            new Interval( 0xA825, 0xA826 ), new Interval( 0xFB1E, 0xFB1E ), new Interval( 0xFE00, 0xFE0F ),
            new Interval( 0xFE20, 0xFE23 ), new Interval( 0xFEFF, 0xFEFF ), new Interval( 0xFFF9, 0xFFFB ),
            new Interval( 0x10A01, 0x10A03 ), new Interval( 0x10A05, 0x10A06 ), new Interval( 0x10A0C, 0x10A0F ),
            new Interval( 0x10A38, 0x10A3A ), new Interval( 0x10A3F, 0x10A3F ), new Interval( 0x1D167, 0x1D169 ),
            new Interval( 0x1D173, 0x1D182 ), new Interval( 0x1D185, 0x1D18B ), new Interval( 0x1D1AA, 0x1D1AD ),
            new Interval( 0x1D242, 0x1D244 ), new Interval( 0xE0001, 0xE0001 ), new Interval( 0xE0020, 0xE007F ),
            new Interval( 0xE0100, 0xE01EF )
    };

    private static class Interval {
        public final int first;
        public final int last;

        public Interval(int first, int last) {
            this.first = first;
            this.last = last;
        }
    }

    /* auxiliary function for binary search in interval table */
    private static boolean bisearch(int ucs, Interval[] table, int max) {
        int min = 0;
        int mid;

        if (ucs < table[0].first || ucs > table[max].last)
            return false;
        while (max >= min) {
            mid = (min + max) / 2;
            if (ucs > table[mid].last)
                min = mid + 1;
            else if (ucs < table[mid].first)
                max = mid - 1;
            else
                return true;
        }

        return false;
    }


}

public class ConsoleReader
{
    public static final String JLINE_NOBELL = ""jline.nobell"";

    public static final String JLINE_ESC_TIMEOUT = ""jline.esc.timeout"";

    public static final String JLINE_INPUTRC = ""jline.inputrc"";

    public static final String INPUT_RC = "".inputrc"";

    public static final String DEFAULT_INPUT_RC = ""/etc/inputrc"";

    public static final char BACKSPACE = '\b';

    public static final char RESET_LINE = '\r';

    public static final char KEYBOARD_BELL = '\07';

    public static final char NULL_MASK = 0;

    public static final int TAB_WIDTH = 8;

    private static final ResourceBundle
        resources = ResourceBundle.getBundle(CandidateListCompletionHandler.class.getName());

    private final Terminal terminal;

    private final Writer out;

    private final CursorBuffer buf = new CursorBuffer();

    private String prompt;
    private int    promptLen;

    private boolean expandEvents = true;

    private boolean bellEnabled = !Configuration.getBoolean(JLINE_NOBELL, true);

    private boolean handleUserInterrupt = false;

    private boolean handleLitteralNext = true;

    private Character mask;

    private Character echoCharacter;

    private StringBuffer searchTerm = null;

    private String previousSearchTerm = """";

    private int searchIndex = -1;

    private int parenBlinkTimeout = 500;

    /*
     * The reader and the nonBlockingInput go hand-in-hand.  The reader wraps
     * the nonBlockingInput, but we have to retain a handle to it so that
     * we can shut down its blocking read thread when we go away.
     */
    private NonBlockingInputStream in;
    private long                   escapeTimeout;
    private Reader                 reader;

    /*
     * TODO: Please read the comments about this in setInput(), but this needs
     * to be done away with.
     */
    private boolean                isUnitTestInput;

    /**
     * Last character searched for with a vi character search
     */
    private char  charSearchChar = 0;           // Character to search for
    private char  charSearchLastInvokeChar = 0; // Most recent invocation key
    private char  charSearchFirstInvokeChar = 0;// First character that invoked

    /**
     * The vi yank buffer
     */
    private String yankBuffer = """";

    private KillRing killRing = new KillRing();

    private String encoding;

    private boolean quotedInsert;

    private boolean recording;

    private String macro = """";

    private String appName;

    private URL inputrcUrl;

    private ConsoleKeys consoleKeys;

    private String commentBegin = null;

    private boolean skipLF = false;

    @Override
    protected void finalize() throws Throwable {
        try {
            shutdown();
        }
        finally {
            super.finalize();
        }
    }

    public InputStream getInput() {
        return in;
    }

    public Writer getOutput() {
        return out;
    }

    public Terminal getTerminal() {
        return terminal;
    }

    public CursorBuffer getCursorBuffer() {
        return buf;
    }

    public void setExpandEvents(final boolean expand) {
        this.expandEvents = expand;
    }

    public boolean getExpandEvents() {
        return expandEvents;
    }
}",Replace Conditional with Polymorphism,"Replace conditional with polymorphism by creating subclasses for each character category and name them [keyword]A, [keyword]B, etc:",FALSE,src/main/java/jline/console/WCWidth.java,https://github.com/jline/jline2/commit/1eb3b624b288a4b1a054420d3efb05b8f1d28517
1143828,"public class MessageEvent {

    public final static EventFactory<MessageEvent> EVENT_FACTORY = new EventFactory<MessageEvent>() {
        @Override
        public MessageEvent newInstance() {
            return new MessageEvent();
        }
    };

    private RawMessage raw;
    private Message msg;
    private List<Message> msgList;

    @Nullable
    public Message getMessage() {
        return msg;
    }

    public void setMessage(@Nullable final Message msg) {
        this.msg = msg;
    }

    @Nullable
    public List<Message> getMessageList() {
        return msgList;
    }

    public void setMessageList(@Nullable final List<Message> msgList) {
        this.msgList = msgList;
    }

    public void setRaw(@Nonnull RawMessage raw) {
        this.raw = raw;
        setMessage(null);
        setMessageList(null);
    }

    public void clearRaw() {
        this.raw = null;
    }

    @Nonnull
    public RawMessage getRaw() {
        return raw;
    }
}

public class DecodingProcessor implements EventHandler<MessageEvent> {
    private static final Logger LOG = LoggerFactory.getLogger(DecodingProcessor.class);

    private final Timer decodeTime;

    public interface Factory {
        public DecodingProcessor create(@Assisted(""decodeTime"") Timer decodeTime, @Assisted(""parseTime"") Timer parseTime);
    }

    private final Map<String, Codec.Factory<? extends Codec>> codecFactory;
    private final ServerStatus serverStatus;
    private final MetricRegistry metricRegistry;
    private final Timer parseTime;

    @AssistedInject
    public DecodingProcessor(Map<String, Codec.Factory<? extends Codec>> codecFactory,
                             final ServerStatus serverStatus,
                             final MetricRegistry metricRegistry,
                             @Assisted(""decodeTime"") Timer decodeTime,
                             @Assisted(""parseTime"") Timer parseTime) {
        this.codecFactory = codecFactory;
        this.serverStatus = serverStatus;
        this.metricRegistry = metricRegistry;

        // these metrics are global to all processors, thus they are passed in directly to avoid relying on the class name
        this.parseTime = parseTime;
        this.decodeTime = decodeTime;
    }

    @Override
    public void onEvent(MessageEvent event, long sequence, boolean endOfBatch) throws Exception {
        final Timer.Context context = decodeTime.time();
        try {
            // always set the result of processMessage, even if it is null, to avoid later stages to process old messages.
            // basically this will make sure old messages are cleared out early.
            event.setMessageList(processMessage(event.getRaw()));
        } finally {
            if (event.getMessageList() != null) {
                for (final Message message : event.getMessageList()) {
                    message.recordTiming(serverStatus, ""decode"", context.stop());
                }
            }
            // aid garbage collection to collect the raw message early (to avoid promoting it to later generations).
            event.clearRaw();
        }
    }

    private Message postProcessMessage(RawMessage raw, Codec codec, String inputIdOnCurrentNode, String baseMetricName, Message message, long decodeTime) {
        if (message == null) {
            metricRegistry.meter(name(baseMetricName, ""failures"")).mark();
            return null;
        }
        if (!message.isComplete()) {
            metricRegistry.meter(name(baseMetricName, ""incomplete"")).mark();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Dropping incomplete message. Parsed fields: [{}]"", message.getFields());
            }
            return null;
        }

        message.setJournalOffset(raw.getJournalOffset());
        message.recordTiming(serverStatus, ""parse"", decodeTime);
        metricRegistry.timer(name(baseMetricName, ""parseTime"")).update(decodeTime, TimeUnit.NANOSECONDS);

        for (final RawMessage.SourceNode node : raw.getSourceNodes()) {
            switch (node.type) {
                case SERVER:
                    // Always use the last source node.
                    if (message.getField(""gl2_source_input"") != null) {
                        LOG.debug(""Multiple server nodes ({} {}) set for message id {}"",
                                message.getField(""gl2_source_input""), node.nodeId, message.getId());
                    }
                    message.addField(""gl2_source_input"", node.inputId);
                    message.addField(""gl2_source_node"", node.nodeId);
                    break;
                case RADIO:
                    // Always use the last source node.
                    if (message.getField(""gl2_source_radio_input"") != null) {
                        LOG.debug(""Multiple radio nodes ({} {}) set for message id {}"",
                                message.getField(""gl2_source_radio_input""), node.nodeId, message.getId());
                    }
                    message.addField(""gl2_source_radio_input"", node.inputId);
                    message.addField(""gl2_source_radio"", node.nodeId);
                    break;
            }
        }

        if (inputIdOnCurrentNode != null) {
            try {
                message.setSourceInputId(inputIdOnCurrentNode);
            } catch (RuntimeException e) {
                LOG.warn(""Unable to find input with id "" + inputIdOnCurrentNode + "", not setting input id in this message."", e);
            }
        }

        final ResolvableInetSocketAddress remoteAddress = raw.getRemoteAddress();
        if (remoteAddress != null) {
            final String addrString = InetAddresses.toAddrString(remoteAddress.getAddress());
            message.addField(""gl2_remote_ip"", addrString);
            if (remoteAddress.getPort() > 0) {
                message.addField(""gl2_remote_port"", remoteAddress.getPort());
            }
            if (remoteAddress.isReverseLookedUp()) { // avoid reverse lookup if the hostname is available
                message.addField(""gl2_remote_hostname"", remoteAddress.getHostName());
            }
            if (Strings.isNullOrEmpty(message.getSource())) {
                message.setSource(addrString);
            }
        }

        if (codec.getConfiguration() != null && codec.getConfiguration().stringIsSet(Codec.Config.CK_OVERRIDE_SOURCE)) {
            message.setSource(codec.getConfiguration().getString(Codec.Config.CK_OVERRIDE_SOURCE));
        }

        // Make sure that there is a value for the source field.
        if (Strings.isNullOrEmpty(message.getSource())) {
            message.setSource(""unknown"");
        }

        metricRegistry.meter(name(baseMetricName, ""processedMessages"")).mark();
        return message;
    }
}",Replace Constructor with Factory Function,"Replace constructor with factory function, create a static create() method to instantiate MessageEvent and name it [keyword]:",FALSE,graylog2-plugin-interfaces/src/main/java/org/graylog2/plugin/buffers/MessageEvent.java,https://github.com/Graylog2/graylog2-server/commit/2d98ae165ea43e9a1ac6a905d6094f077abb2e55
1138530,"public class ClientDelegatingFuture<V> implements ICompletableFuture<V> {

    private final ClientInvocationFuture future;
    private final SerializationService serializationService;
    private final V defaultValue;
    private final Object mutex = new Object();
    private Throwable error;
    private V deserializedValue;
    private Data valueData;
    private volatile boolean done;

	public ClientDelegatingFuture(ClientInvocationFuture clientInvocationFuture,
								SerializationService serializationService, V defaultValue) {
        this.future = clientInvocationFuture;
        this.serializationService = serializationService;
        this.defaultValue = defaultValue;
    }

	@Override
	public int getWithErrorCode() {
			try {
					V result = get(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
					return 0;
			} catch (TimeoutException e) {
					return -1;
			}
	}

    public void andThenInternal(final ExecutionCallback<Data> callback) {
        future.andThenInternal(new DelegatingExecutionCallback<Data>(callback, false));
    }

    @Override
    public void andThen(final ExecutionCallback<V> callback) {
        future.andThen(new DelegatingExecutionCallback<V>(callback, true));
    }

    @Override
    public void andThen(final ExecutionCallback<V> callback, Executor executor) {
        future.andThen(new DelegatingExecutionCallback<V>(callback, true), executor);
    }

	@Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        done = true;
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public final boolean isDone() {
        return done ? done : future.isDone();
    }

    public Data getValueData() {
        return valueData;
    }

    @Override
    public V get() throws InterruptedException, ExecutionException {
        try {
            return get(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            return ExceptionUtil.sneakyThrow(e);
        }
    }

    @Override
    public V get(long timeout, TimeUnit unit) throws InterruptedException,
            ExecutionException, TimeoutException {
        if (!done) {
            synchronized (mutex) {
                if (!done) {
                    try {
                        valueData = resolveMessageToValue(future.get(timeout, unit));
                        if (deserializedValue == null) {
                            deserializedValue = serializationService.toObject(valueData);
                        }
                    } catch (InterruptedException e) {
                        error = e;
                    } catch (ExecutionException e) {
                        error = e;
                    }
                    done = true;
                }
            }
        }
        if (error != null) {
            if (error instanceof ExecutionException) {
                throw (ExecutionException) error;
            }
            if (error instanceof CancellationException) {
                throw (CancellationException) error;
            }
            if (error instanceof InterruptedException) {
                throw (InterruptedException) error;
            }
            // should not happen!
            throw new ExecutionException(error);
        }
        return getResult();
    }

    private V getResult() {
        if (defaultValue != null) {
            return defaultValue;
        }

        // If value is already deserialized, use it.
        if (deserializedValue != null) {
            return deserializedValue;
        } else {
            // Otherwise, it is possible that received data may not be deserialized
            // if ""shouldDeserializeData"" flag is not true in any of registered ""DelegatingExecutionCallback"".
            // So, be sure that value is deserialized before returning to caller.
            if (valueData != null) {
                deserializedValue = serializationService.toObject(valueData);
            }
            return deserializedValue;
        }
    }

    private Data resolveMessageToValue(ClientMessage message) {
        return ExecutorServiceSubmitToPartitionCodec.decodeResponse(message).response;
    }

    protected void setError(Throwable error) {
        this.error = error;
    }

    protected void setDone() {
        this.done = true;
    }

    protected ClientInvocationFuture getFuture() {
        return future;
    }

    class DelegatingExecutionCallback<T> implements ExecutionCallback<ClientMessage> {

        private final ExecutionCallback<T> callback;
        private final boolean shouldDeserializeData;

        DelegatingExecutionCallback(ExecutionCallback<T> callback, boolean shouldDeserializeData) {
            this.callback = callback;
            this.shouldDeserializeData = shouldDeserializeData;
        }

        @Override
        public void onResponse(ClientMessage message) {
            if (!done) {
                synchronized (mutex) {
                    if (!done) {
                        valueData = resolveMessageToValue(message);
                        if (shouldDeserializeData && deserializedValue == null) {
                            deserializedValue = serializationService.toObject(valueData);
                        }
                        done = true;
                    }
                }
            }
            if (shouldDeserializeData) {
                callback.onResponse((T) deserializedValue);
            } else {
                callback.onResponse((T) valueData);
            }
        }

        @Override
        public void onFailure(Throwable t) {
            if (!done) {
                synchronized (mutex) {
                    if (!done) {
                        error = t;
                        done = true;
                    }
                }
            }
            callback.onFailure(t);
        }
    }
}",Replace Error Code with Exception,Replace the error code with an exception and name it [keyword]:,FALSE,hazelcast-client-new/src/main/java/com/hazelcast/client/util/ClientDelegatingFuture.java,https://github.com/hazelcast/hazelcast/commit/679d38d4316c16ccba4982d7f3ba13c147a451cb
1137576,"private void process(ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements) {
    for (ProcessingStep step : steps) {
        SetMultimap<Class<? extends Annotation>, Element> filteredMap =
            Multimaps.filterKeys(validElements, Predicates.in(step.annotations()));
        if (!filteredMap.isEmpty()) {
            step.process(filteredMap);
        }
    }
}

private static void findAnnotatedElements(Element element,
    ImmutableSet<? extends Class<? extends Annotation>> annotationClasses,
    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> builder) {
    for (Element enclosedElement : element.getEnclosedElements()) {
        findAnnotatedElements(enclosedElement, annotationClasses, builder);
    }
    // element.getEnclosedElements() does NOT return parameter elements
    if (element instanceof ExecutableElement) {
        for (Element parameterElement : ((ExecutableElement) element).getParameters()) {
            findAnnotatedElements(parameterElement, annotationClasses, builder);
        }
    }
    for (Class<? extends Annotation> annotationClass : annotationClasses) {
        if (MoreElements.isAnnotationPresent(element, annotationClass)) {
            builder.put(annotationClass, element);
        }
    }
}

private ImmutableSet<? extends Class<? extends Annotation>> getSupportedAnnotationClasses() {
checkState(steps != null);
ImmutableSet.Builder<Class<? extends Annotation>> builder = ImmutableSet.builder();
for (ProcessingStep step : steps) {
	builder.addAll(step.annotations());
}
return builder.build();
}

@Override
public final ImmutableSet<String> getSupportedAnnotationTypes() {
ImmutableSet.Builder<String> builder = ImmutableSet.builder();
for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
	builder.add(annotationClass.getCanonicalName());
}
return builder.build();
}

private static final String INVALID_ELEMENT_MESSAGE_FORMAT = ""%s was unable to process %s""
	+ "" because not all of its dependencies could be resolved. Check for compilation errors or a""
	+ "" circular dependency with generated code."";

private ImmutableMap<String, Optional<? extends Element>> deferredElements() {
ImmutableMap.Builder<String, Optional<? extends Element>> deferredElements =
	ImmutableMap.builder();
for (String deferredTypeName : deferredTypeNames) {
	deferredElements.put(
		deferredTypeName, Optional.fromNullable(elements.getTypeElement(deferredTypeName)));
}

for (String deferredPackageName : deferredPackageNames) {
	deferredElements.put(
		deferredPackageName,
		Optional.fromNullable(elements.getPackageElement(deferredPackageName)));
}

return deferredElements.build();
}

private void reportMissingElements(
	Map<String, ? extends Optional<? extends Element>> missingElements) {
for (Entry<String, ? extends Optional<? extends Element>> missingElementEntry :
	missingElements.entrySet()) {
	Optional<? extends Element> missingElement = missingElementEntry.getValue();
	if (missingElement.isPresent()) {
	processingEnv
		.getMessager()
		.printMessage(
			ERROR,
			String.format(
				INVALID_ELEMENT_MESSAGE_FORMAT,
				processorName,
				""this "" + Ascii.toLowerCase(missingElement.get().getKind().name())),
			missingElement.get());
	} else {
	processingEnv
		.getMessager()
		.printMessage(
			ERROR,
			String.format(
				INVALID_ELEMENT_MESSAGE_FORMAT, processorName, missingElementEntry.getKey()));
	}
}
}

private ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements(
	ImmutableMap<String, Optional<? extends Element>> deferredElements,
	RoundEnvironment roundEnv) {
ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>
	deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();
for (Entry<String, Optional<? extends Element>> deferredTypeElementEntry :
	deferredElements.entrySet()) {
	Optional<? extends Element> deferredElement = deferredTypeElementEntry.getValue();
	if (deferredElement.isPresent()) {
	findAnnotatedElements(deferredElement.get(), getSupportedAnnotationClasses(),
		deferredElementsByAnnotationBuilder);
	} else {
	deferredTypeNames.add(deferredTypeElementEntry.getKey());
	}
}

ImmutableSetMultimap<Class<? extends Annotation>, Element> deferredElementsByAnnotation =
	deferredElementsByAnnotationBuilder.build();

ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> validElements =
	ImmutableSetMultimap.builder();

Set<String> validPackageNames = Sets.newLinkedHashSet();
Set<String> validTypeNames = Sets.newLinkedHashSet();

// Look at the elements we've found and the new elements from this round and validate them.
for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
	// This should just call roundEnv.getElementsAnnotatedWith(Class) directly, but there is a bug
	// in some versions of eclipse that cause that method to crash.
	TypeElement annotationType = elements.getTypeElement(annotationClass.getCanonicalName());
	Set<? extends Element> elementsAnnotatedWith =
		(annotationType == null)
			? ImmutableSet.<Element>of()
			: roundEnv.getElementsAnnotatedWith(annotationType);
	for (Element annotatedElement :
		Sets.union(elementsAnnotatedWith, deferredElementsByAnnotation.get(annotationClass))) {
	if (annotatedElement.getKind().equals(PACKAGE)) {
		PackageElement annotatedPackageElement = (PackageElement) annotatedElement;
		String annotatedPackageName = annotatedPackageElement.getQualifiedName().toString();
		boolean validPackage =
			validPackageNames.contains(annotatedPackageName)
				|| (!deferredPackageNames.contains(annotatedPackageName)
					&& validateElement(annotatedPackageElement));
		if (validPackage) {
		validElements.put(annotationClass, annotatedPackageElement);
		validPackageNames.add(annotatedPackageName);
		} else {
		deferredPackageNames.add(annotatedPackageName);
		}
	} else {
		TypeElement enclosingType = getEnclosingType(annotatedElement);
		String enclosingTypeName = enclosingType.getQualifiedName().toString();
		boolean validEnclosingType =
			validTypeNames.contains(enclosingTypeName)
				|| (!deferredTypeNames.contains(enclosingTypeName)
					&& validateElement(enclosingType));
		if (validEnclosingType) {
		validElements.put(annotationClass, annotatedElement);
		validTypeNames.add(enclosingTypeName);
		} else {
		deferredTypeNames.add(enclosingTypeName);
		}
	}
	}
}

return validElements.build();
}

/** Processes the valid elements. */
private void process(ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements) {
for (ProcessingStep step : steps) {
	SetMultimap<Class<? extends Annotation>, Element> filteredMap =
		Multimaps.filterKeys(validElements, Predicates.in(step.annotations()));
	if (!filteredMap.isEmpty()) {
	step.process(filteredMap);
	}
}
}

private static TypeElement getEnclosingType(Element element) {
return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
	@Override protected TypeElement defaultAction(Element e, Void p) {
	return e.getEnclosingElement().accept(this, p);
	}

	@Override public TypeElement visitType(TypeElement e, Void p) {
	return e;
	}

	@Override public TypeElement visitPackage(PackageElement e, Void p) {
	throw new IllegalArgumentException();
	}
}, null);
}",Replace Function with Command,"Replace function with command, encapsulate the processing of valid elements into a command class and name it [keyword]:",FALSE,common/src/main/java/com/google/auto/common/BasicAnnotationProcessor.java,https://github.com/google/auto/commit/8fc60d81fe0e46e7e5c96e71d4a93fcadc6bde4f
1135909,"public class WebContentInterceptor extends WebContentGenerator {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws ServletException {

        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);

        if (logger.isDebugEnabled()) {
            logger.debug(""Looking up cache seconds for ["" + lookupPath + ""]"");
        }

        CacheControl cacheControl = lookupCacheControl(lookupPath);
        Integer cacheSeconds = lookupCacheSeconds(lookupPath);

        if (cacheControl != null) {
            if (logger.isDebugEnabled()) {
                logger.debug(""Applying CacheControl to ["" + lookupPath + ""]"");
            }
            checkAndPrepare(request, response, cacheControl);
        } else if (cacheSeconds != null) {
            if (logger.isDebugEnabled()) {
                logger.debug(""Applying CacheControl to ["" + lookupPath + ""]"");
            }
            checkAndPrepare(request, response, cacheSeconds);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(""Applying default cache seconds to ["" + lookupPath + ""]"");
            }
            checkAndPrepare(request, response, 60);
        }

        return true;
    }

	protected CacheControl lookupCacheControl(String urlPath) {
		// direct match?
		CacheControl cacheControl = this.cacheControlMappings.get(urlPath);
		if (cacheControl == null) {
			// pattern match?
			for (String registeredPath : this.cacheControlMappings.keySet()) {
				if (this.pathMatcher.match(registeredPath, urlPath)) {
					cacheControl = this.cacheControlMappings.get(registeredPath);
				}
			}
		}
		return cacheControl;
	}

	protected Integer lookupCacheSeconds(String urlPath) {
		// direct match?
		Integer cacheSeconds = this.cacheMappings.get(urlPath);
		if (cacheSeconds == null) {
			// pattern match?
			for (String registeredPath : this.cacheMappings.keySet()) {
				if (this.pathMatcher.match(registeredPath, urlPath)) {
					cacheSeconds = this.cacheMappings.get(registeredPath);
				}
			}
		}
		return cacheSeconds;
	}


	/**
	 * This implementation is empty.
	 */
	@Override
	public void postHandle(
			HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
			throws Exception {
	}

	/**
	 * This implementation is empty.
	 */
	@Override
	public void afterCompletion(
			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
	}

}

public abstract class WebContentGenerator extends WebApplicationObjectSupport {

	/** HTTP method ""GET"" */
	public static final String METHOD_GET = ""GET"";

	/** HTTP method ""HEAD"" */
	public static final String METHOD_HEAD = ""HEAD"";

	/** HTTP method ""POST"" */
	public static final String METHOD_POST = ""POST"";

	private static final String HEADER_PRAGMA = ""Pragma"";

	private static final String HEADER_EXPIRES = ""Expires"";

	private static final String HEADER_CACHE_CONTROL = ""Cache-Control"";


	/** Set of supported HTTP methods */
	private Set<String> supportedMethods;

	private boolean requireSession = false;

	private int cacheSeconds = -1;

	/** Use HTTP 1.0 expires header? */
	private boolean useExpiresHeader = true;

	/** Use HTTP 1.1 cache-control header? */
	private boolean useCacheControlHeader = true;

	/** Use HTTP 1.1 cache-control header value ""no-store""? */
	private boolean useCacheControlNoStore = true;

	private boolean alwaysMustRevalidate = false;

	private boolean usePreviousHttpCachingBehavior = false;

	private final SimpleDateFormat dateFormat;

	private CacheControl cacheControl;


	/**
	 * Create a new WebContentGenerator which supports
	 * HTTP methods GET, HEAD and POST by default.
	 */
	public WebContentGenerator() {
		this(true);
	}

	/**
	 * Create a new WebContentGenerator.
	 * @param restrictDefaultSupportedMethods {@code true} if this
	 * generator should support HTTP methods GET, HEAD and POST by default,
	 * or {@code false} if it should be unrestricted
	 */
	public WebContentGenerator(boolean restrictDefaultSupportedMethods) {
		if (restrictDefaultSupportedMethods) {
			this.supportedMethods = new HashSet<String>(4);
			this.supportedMethods.add(METHOD_GET);
			this.supportedMethods.add(METHOD_HEAD);
			this.supportedMethods.add(METHOD_POST);
		}
		dateFormat = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z"", Locale.US);
		dateFormat.setTimeZone(TimeZone.getTimeZone(""GMT""));
	}

	/**
	 * Create a new WebContentGenerator.
	 * @param supportedMethods the supported HTTP methods for this content generator
	 */
	public WebContentGenerator(String... supportedMethods) {
		this.supportedMethods = new HashSet<String>(Arrays.asList(supportedMethods));
		dateFormat = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z"", Locale.US);
		dateFormat.setTimeZone(TimeZone.getTimeZone(""GMT""));
	}


	/**
	 * Set the HTTP methods that this content generator should support.
	 * <p>Default is GET, HEAD and POST for simple form controller types;
	 * unrestricted for general controllers and interceptors.
	 */
	public final void setSupportedMethods(String... methods) {
		if (methods != null) {
			this.supportedMethods = new HashSet<String>(Arrays.asList(methods));
		}
		else {
			this.supportedMethods = null;
		}
	}

	/**
	 * Return the HTTP methods that this content generator supports.
	 */
	public final String[] getSupportedMethods() {
		return StringUtils.toStringArray(this.supportedMethods);
	}

	/**
	 * Set whether a session should be required to handle requests.
	 */
	public final void setRequireSession(boolean requireSession) {
		this.requireSession = requireSession;
	}

	/**
	 * Return whether a session is required to handle requests.
	 */
	public final boolean isRequireSession() {
		return this.requireSession;
	}

	/**
	 * Set the {@link org.springframework.http.CacheControl} instance to build
	 * the Cache-Control HTTP response header.
	 *
	 * @since 4.2
	 */
	public void setCacheControl(CacheControl cacheControl) {
		this.cacheControl = cacheControl;
	}

	/**
	 * Get the {@link org.springframework.http.CacheControl} instance
	 * that builds the Cache-Control HTTP response header.
	 *
	 * @since 4.2
	 */
	public CacheControl getCacheControl() {
		return cacheControl;
	}
}",Replace Magic Literal,"Replace the magic literal ""60"" with a constant and name it [keyword]:",FALSE,spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/WebContentInterceptor.java,https://github.com/spring-projects/spring-framework/commit/ef0eb01f93d6c485cf37692fd193833a6821272a
1135604,"private double computeNextStep(double alam, double fold, double f, double slope, double a, double b) {
    final double relTolx = 1e-10;
    final double absTolx = 1e-4;
    final double ALF = 1e-4;

    double tmplam;

    if (alam == 1.0) {
        double numerator = -slope;
        double denominator = 2.0 * (f - fold - slope);
        tmplam = numerator / denominator;
    } else {
        double discriminant = b * b - 3.0 * a * slope;

        if (discriminant < 0.0) {
            tmplam = 0.5 * alam;
        } else if (b <= 0.0) {
            tmplam = (-b + FastMath.sqrt(discriminant)) / (3.0 * a);
        } else {
            double sqrtDisc = FastMath.sqrt(discriminant);
            tmplam = -slope / (b + sqrtDisc);
        }
    }

    double maxStep = 0.5 * alam;
    if (tmplam > maxStep) {
        tmplam = maxStep;
    }

    double minStep = 0.1 * alam;
    alam = Math.max(tmplam, minStep);

    if (logger.isDebugEnabled()) {
        logger.debug(""computeNextStep: tmplam="" + tmplam + "", alam="" + alam +
                     "", slope="" + slope + "", fold="" + fold + "", f="" + f +
                     "", a="" + a + "", b="" + b);
    }

    return alam;
}

public BackTrackLineSearch(Model layer, StepFunction stepFunction, ConvexOptimizer optimizer) {
	this.layer = layer;
	this.stepFunction = stepFunction;
	this.optimizer = optimizer;
}

/**
 *
 * @param optimizable
 * @param optimizer
 */
public BackTrackLineSearch(Model optimizable, ConvexOptimizer optimizer) {
	this(optimizable, new DefaultStepFunction(),optimizer);
}


public void setStpmax(double stpmax) {
	this.stpmax = stpmax;
}


public double getStpmax() {
	return stpmax;
}

/**
 * Sets the tolerance of relative diff in function value.
 *  Line search converges if abs(delta x / x) < tolx
 *  for all coordinates. */
public void setRelTolx (double tolx) { relTolx = tolx; }

/**
 * Sets the tolerance of absolute diff in function value.
 *  Line search converges if abs(delta x) < tolx
 *  for all coordinates. */
public void setAbsTolx (double tolx) { absTolx = tolx; }

public int getMaxIterations() {
	return maxIterations;
}

public void setMaxIterations(int maxIterations) {
	this.maxIterations = maxIterations;
}

// initialStep is ignored.  This is b/c if the initial step is not 1.0,
//   it sometimes confuses the backtracking for reasons I don't
//   understand.  (That is, the jump gets LARGER on iteration 1.)

// returns fraction of step size (alam) if found a good step
// returns 0.0 if could not step in direction

private double getNewScore(INDArray oldParameters){
	layer.setParams(oldParameters);
	layer.setScore();
	return layer.score();
}

/**
 *
 * @param initialStep the initial step size
 * @param parameters the parameters to optimize
 * @param gradients the line/rate of change
 * @return the next step size
 * @throws InvalidStepException
 */
public double optimize (double initialStep, INDArray parameters, INDArray gradients) throws InvalidStepException {
	double test, alamin, alam, alam2, oldAlam, tmplam;
	double rhs1, rhs2, a, b, disc, f, fold, f2;

	INDArray oldParameters = parameters.dup();
	INDArray gDup = gradients.dup();
	double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);
	double slope = Nd4j.getBlasWrapper().dot(gDup, gradients);

	INDArray maxOldParams = abs(oldParameters);
	Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));
	INDArray testMatrix = abs(gradients).divi(maxOldParams);
	test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);

	alam  = 1.0; // initially, alam = 1.0, i.e. take full Newton step
	alamin = relTolx / test; // relative convergence tolerance
	oldAlam = 0.0;
	alam2 = 0.0;

	f2 = fold = layer.score();

	if (logger.isDebugEnabled()) {
		logger.trace (""ENTERING BACKTRACK\n"");
		logger.trace(""Entering BackTrackLinnSearch, value = "" + fold + "",\ndirection.oneNorm:""
				+	gDup.norm1(Integer.MAX_VALUE) + ""  direction.infNorm:""+
				FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));
	}

	if(sum > stpmax) {
		logger.warn(""attempted step too big. scaling: sum= "" + sum +
				"", stpmax= ""+ stpmax);
		gradients.muli(stpmax / sum);
	}

	logger.debug(""slope = "" + slope);

	if (slope < 0)
		throw new InvalidStepException(""Slope = "" + slope + "" is negative"");
	else if (slope == 0)
		throw new InvalidStepException (""Slope = "" + slope + "" is zero"");

	// find maximum lambda
	// converge when (delta x) / x < REL_TOLX for all coordinates.
	// the largest step size that triggers this threshold is precomputed and saved in alamin
	// look for step size in direction given by ""line""

	for(int iteration = 0; iteration < maxIterations; iteration++) {
		logger.trace(""BackTrack loop iteration "" + iteration +"" : alam="" + alam +"" oldAlam="" + oldAlam);
		logger.trace (""before step, x.1norm: "" + parameters.norm1(Integer.MAX_VALUE) +  ""\nalam: "" + alam + ""\noldAlam: "" + oldAlam);
		assert(alam != oldAlam) : ""alam == oldAlam"";

		if(stepFunction == null)
			stepFunction =  new DefaultStepFunction();
		//scale wrt updates
		stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step
		oldAlam = alam;

		if(logger.isDebugEnabled())  {
			double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);
			logger.debug (""after step, x.1norm: "" + norm1);
		}

		// check for convergence on delta x
		// if all of the parameters are < 1e-12

		if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,
				parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {
			f = getNewScore(oldParameters);
			logger.trace(""EXITING BACKTRACK: Jump too small (alamin = ""+ alamin + ""). Exiting and using xold. Value = "" + f);
			return 0.0;
		}

		f = getNewScore(oldParameters);
		logger.debug(""value = "" + f);

		// sufficient increase (Wolf condition)

		if(f >= fold + ALF * alam * slope) {

			logger.debug(""EXITING BACKTRACK: value="" + f);
			if (f < fold)
				throw new IllegalStateException
						(""Function did not increase: f = "" + f + "" < "" + fold + "" = fold"");
			return alam;
		}

		// if value is infinite, i.e. we've
		// jumped to unstable territory, then scale down jump

		else if(Double.isInfinite(f) || Double.isInfinite(f2)) {
			logger.warn (""Value is infinite after jump "" + oldAlam + "". f=""+ f +"", f2="" + f2 + "". Scaling back step size..."");
			tmplam = .2 * alam;
			if(alam < alamin) { //convergence on delta x
				f = getNewScore(oldParameters);
				logger.warn(""EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=""+ f );
				return 0.0;
			}
		}

		// backtrack

		else {
			if(alam == 1.0) // first time through
				tmplam = -slope / (2.0 * ( f - fold - slope ));
			else {
				rhs1 = f - fold- alam * slope;
				rhs2 = f2 - fold - alam2 * slope;
				if(alam == alam2)
					throw new IllegalStateException(""FAILURE: dividing by alam-alam2. alam="" + alam);
				a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);
				b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);
				if(a == 0.0)
					tmplam = -slope / (2.0 * b);
				else {
					disc = b * b - 3.0 * a * slope;
					if(disc < 0.0) {
						tmplam = .5f * alam;
					}
					else if (b <= 0.0)
						tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );
					else
						tmplam = -slope / (b +FastMath.sqrt(disc));
				}
				if (tmplam > .5f * alam)
					tmplam = .5f * alam;    // lambda <= .5 lambda_1
			}
		}

		alam2 = alam;
		f2 = f;
		logger.debug(""tmplam:"" + tmplam);
		alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1

	}

	return 0.0;
}
",Replace Primitive with Object,Replace the primitive doubles with an object and name it [keyword]:,FALSE,deeplearning4j-core/src/main/java/org/deeplearning4j/optimize/solvers/BackTrackLineSearch.java,https://github.com/deeplearning4j/deeplearning4j/commit/91cdfa1ffd937a4cb01cdc0052874ef7831955e2
1133355,"public class ChannelCloseEofTest extends SshIntegrationTestBase {
    private SSHClient sshClient;

    @Before
    public void setUp() throws Exception {
        sshClient = new SSHClient();
    }

    @After
    public void tearDown() throws IOException {
        sshClient.disconnect();
    }

    @Test
    public void shouldCorrectlyHandleSessionChannelEof() throws IOException, InterruptedException {
        sshClient.addHostKeyVerifier(new PromiscuousVerifier());
        sshClient.connect(server.getHost(), server.getPort());
        sshClient.authPassword(""jeroen"", ""jeroen"");
        Session session = sshClient.startSession();
        session.allocateDefaultPTY();
        session.close();
        Thread.sleep(1000);
        assertThat(""Should still be connected"", sshClient.isConnected());
    }

}

public class ChannelCloseEofTest extends SshIntegrationTestBase {
    private SSHClient sshClient;

    @Before
    public void setUp() throws Exception {
        sshClient = new SSHClient();
    }

    @After
    public void tearDown() throws IOException {
        sshClient.disconnect();
    }

    @Test
    public void shouldCorrectlyHandleSessionChannelEof() throws IOException, InterruptedException {
        sshClient.addHostKeyVerifier(new PromiscuousVerifier());
        sshClient.connect(server.getHost(), server.getPort());
        sshClient.authPassword(""jeroen"", ""jeroen"");
        Session session = sshClient.startSession();
        session.allocateDefaultPTY();
        session.close();
        Thread.sleep(1000);
        assertThat(""Should still be connected"", sshClient.isConnected());
    }

}

public class SshIntegrationTestBase {
    public static final String hostkey = ""src/test/resources/hostkey.pem"";
    public static final String fingerprint = ""ce:a7:c1:cf:17:3f:96:49:6a:53:1a:05:0b:ba:90:db"";

    public static final String hostname = ""localhost"";

    protected SshServer server = null;

    @Before
    public void setupSshServer() throws IOException {
        server = SshServer.setUpDefaultServer();
        server.setPort(randomPort());
        configureSshServer();
        server.start();
    }

    @After
    public void stopSshServer() throws Exception {
        server.stop();
    }

    protected void configureSshServer() {
        server.setKeyPairProvider(new FileKeyPairProvider(new String[]{hostkey}));
        server.setPasswordAuthenticator(new PasswordAuthenticator() {
            @Override
            public boolean authenticate(String username, String password, ServerSession session) {
                return username.equals(password);
            }
        });
    }

    private int randomPort() {
        try {
            ServerSocket s = null;
            try {
                s = new ServerSocket(0);
                return s.getLocalPort();
            } finally {
                if (s != null)
                    s.close();
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

}

public class OpenSSHKeyFileTest {

    static final String g = ""23b0484f5ad9cba2b3dba7129419fbec7f8c014e22d3b19de4ebbca20d0ebd2e9f5225dabdd48de75f87e3193377fb1072c08433f82f6e6e581a319d4fc7d283cdcd2ae2000fe572c0a800fd47b7590d6a6afe3df54aedd57696c6538029daebf11d9e277edc0c7e905e237d3b9e6a6f674d83da5cc0131ac0be2e55ac69730e"";
    static final String p = ""92b746cf7c0e9ea35fd9b09b0c3dbdfde453468984698ff168fefef3f0457d29bcf81c88830ac1099223d00745423e44cdef66f4cdc3fad1d95ce2868b3e885c1d518c9fcda597d5c373f05f6f323553f60bd992404183dab41d82ab6d3b3ecf2dfc3c136fa67c4312ec0b7bbac77a634e1eb5dd9a62efd0ddab477d0b49c0b9"";
    static final String q = ""96a05e07b9e52d6f1137d11d5d270b568b94162f"";
    static final String x = ""8981aebb71c60b5951f0ab3ed1a00b5307742f43"";
    static final String y = ""7e845aada202d31004c52ab170cbe62ce9a962b9f4acbc67a57f62eb090a67b3faa53d38050f87b2b66ddf1185472f27842c3e3e58d025f9148a28f49ebdfb6efefee8ee10fe84a2d56535dddb301dfee15538108639e8a0ec7aa237ddb999f35b6a5c6b875052998233374163ad031f974d29c2631394436ae186b418348193"";

    boolean readyToProvide;

    final char[] correctPassphrase = ""test_passphrase"".toCharArray();
    final char[] incorrectPassphrase = new char[]{' '};

    final PasswordFinder onlyGivesWhenReady = new PasswordFinder() {
        @Override
        public char[] reqPassword(Resource resource) {
            if (!readyToProvide)
                throw new AssertionError(""Password requested too soon"");

            return correctPassphrase;
        }

        @Override
        public boolean shouldRetry(Resource resource) {
            return false;
        }
    };

    int triesLeft = 3;

    final PasswordFinder givesOn3rdTry = new PasswordFinder() {
        @Override
        public char[] reqPassword(Resource resource) {
            if (triesLeft == 0)
                return correctPassphrase;
            else {
                triesLeft--;
                return incorrectPassphrase;
            }
        }

        @Override
        public boolean shouldRetry(Resource resource) {
            return triesLeft >= 0;
        }
    };

    @Test
    public void blankingOut()
            throws IOException, GeneralSecurityException {
        FileKeyProvider dsa = new OpenSSHKeyFile();
        dsa.init(new File(""src/test/resources/id_dsa""), PasswordUtils.createOneOff(correctPassphrase));
        assertEquals(KeyUtil.newDSAPrivateKey(x, p, q, g), dsa.getPrivate());

        char[] blank = new char[correctPassphrase.length];
        Arrays.fill(blank, ' ');
        assertArrayEquals(blank, correctPassphrase);
    }

    @Test
    public void getters()
            throws IOException, GeneralSecurityException {
        FileKeyProvider dsa = new OpenSSHKeyFile();
        dsa.init(new File(""src/test/resources/id_dsa""), onlyGivesWhenReady);
        assertEquals(dsa.getType(), KeyType.DSA);
        assertEquals(KeyUtil.newDSAPublicKey(y, p, q, g), dsa.getPublic());
        readyToProvide = true;
        assertEquals(KeyUtil.newDSAPrivateKey(x, p, q, g), dsa.getPrivate());
    }

    @Test
    public void retries()
            throws IOException, GeneralSecurityException {
        FileKeyProvider dsa = new OpenSSHKeyFile();
        dsa.init(new File(""src/test/resources/id_dsa""), givesOn3rdTry);
        assertEquals(KeyUtil.newDSAPrivateKey(x, p, q, g), dsa.getPrivate());
    }

    @Test
    public void fromString()
            throws IOException, GeneralSecurityException {
        FileKeyProvider dsa = new OpenSSHKeyFile();
        String privateKey = readFile(""src/test/resources/id_dsa"");
        String publicKey = readFile(""src/test/resources/id_dsa.pub"");
        dsa.init(privateKey, publicKey,
                 PasswordUtils.createOneOff(correctPassphrase));
        assertEquals(dsa.getType(), KeyType.DSA);
        assertEquals(KeyUtil.newDSAPublicKey(y, p, q, g), dsa.getPublic());
        assertEquals(KeyUtil.newDSAPrivateKey(x, p, q, g), dsa.getPrivate());
    }

    @Before
    public void setup()
            throws UnsupportedEncodingException, GeneralSecurityException {
        if (!SecurityUtils.isBouncyCastleRegistered())
            throw new AssertionError(""bouncy castle needed"");
    }

    private String readFile(String pathname)
            throws IOException {
        StringBuilder fileContents = new StringBuilder();
        Scanner scanner = new Scanner(new File(pathname));
        String lineSeparator = System.getProperty(""line.separator"");
        try {
            while (scanner.hasNextLine()) {
                fileContents.append(scanner.nextLine() + lineSeparator);
            }
            return fileContents.toString();
        } finally {
            scanner.close();
        }
    }
}",Replace Subclass with Delegate,Replace the subclass with a delegate and name it [keyword]:,FALSE,MPDroid/src/main/java/com/namelessdev/mpdroid/widgets/WidgetHelperService.java,https://github.com/abarisain/dmix/commit/885771d57c97bd2dd48951e8aeaaa87ceb87532b
1126375,"public class PartTreeJpaQuery extends AbstractJpaQuery {

    private final QueryPreparer query;
    private final QueryPreparer countQuery;
    private final EntityManager em;

    public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em) {
        super(method, em);
        this.em = em;
        this.countQuery = new CountQueryPreparer(method.getParameters().potentiallySortsDynamically());
        this.query = new QueryPreparer(method.getParameters().potentiallySortsDynamically());
    }

    @Override
    public Query doCreateQuery(Object[] values) {
        return query.createQuery(values);
    }

    @Override
    @SuppressWarnings(""unchecked"")
    public TypedQuery<Long> doCreateCountQuery(Object[] values) {
        return (TypedQuery<Long>) countQuery.createQuery(values);
    }

    @Override
    protected JpaQueryExecution getExecution() {
        return super.getExecution();
    }

    private class QueryPreparer {

		private final CriteriaQuery<?> cachedCriteriaQuery;
		private final List<ParameterMetadata<?>> expressions;

		public QueryPreparer(boolean recreateQueries) {

			JpaQueryCreator creator = createCreator(null);
			this.cachedCriteriaQuery = recreateQueries ? null : creator.createQuery();
			this.expressions = recreateQueries ? null : creator.getParameterExpressions();
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 * 
		 * @param values
		 * @return
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			List<ParameterMetadata<?>> expressions = this.expressions;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(accessor);
				criteriaQuery = potentiallyAugment(creator.createQuery(getDynamicSort(values)));
				expressions = creator.getParameterExpressions();
			}

			TypedQuery<?> jpaQuery = createQuery(criteriaQuery);

			return restrictMaxResultsIfNecessary(invokeBinding(getBinder(values, expressions), jpaQuery));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 * 
		 * @param query
		 * @return
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and snychronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case).
		 * 
		 * @see DATAJPA-396
		 * @param criteriaQuery must not be {@literal null}.
		 * @return
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query) {
			return potentiallyAugment(query, QueryMode.FIND);
		}

		private <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query, QueryMode mode) {

			QueryAugmentationEngine engine = getAugmentationEngine();

			if (engine.augmentationNeeded(JpaCriteriaQueryContext.class, mode, entityInformation)) {
				JpaCriteriaQueryContext<T, T> context = new JpaCriteriaQueryContext<T, T>(mode, getEntityManager(), query,
						entityInformation, null);
				return engine.invokeAugmentors(context).getQuery();
			} else {
				return query;
			}
		}

		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();
			PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(entityManager);

			ParameterMetadataProvider provider = accessor == null ? new ParameterMetadataProvider(builder, parameters,
					persistenceProvider) : new ParameterMetadataProvider(builder, accessor, persistenceProvider);

			return new JpaQueryCreator(tree, domainClass, builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 * 
		 * @param binder
		 * @param query
		 * @return
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query) {

			return binder.bindAndPrepare(query);
		}

		private ParameterBinder getBinder(Object[] values, List<ParameterMetadata<?>> expressions) {
			return new CriteriaQueryParameterBinder(parameters, values, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() ? new ParametersParameterAccessor(parameters, values).getSort()
					: null;
		}
	}

    private class CountQueryPreparer extends QueryPreparer {

		public CountQueryPreparer(boolean recreateQueries) {
			super(recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor)
		 */
		@Override
		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();
			PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(entityManager);

			ParameterMetadataProvider provider = accessor == null ? new ParameterMetadataProvider(builder, parameters,
					persistenceProvider) : new ParameterMetadataProvider(builder, accessor, persistenceProvider);

			return new JpaCountQueryCreator(tree, domainClass, builder, provider);
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#potentiallyAugment(javax.persistence.criteria.CriteriaQuery)
		 */
		@Override
		protected <T> CriteriaQuery<T> potentiallyAugment(CriteriaQuery<T> query) {
			return super.potentiallyAugment(query, QueryMode.COUNT_FOR_PAGING);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#invokeBinding(org.springframework.data.jpa.repository.query.ParameterBinder,
		 *      javax.persistence.TypedQuery)
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, javax.persistence.TypedQuery<?> query) {
			return binder.bind(query);
		}
	}
}",Replace Superclass with Delegate,Replace the superclass with a delegate and name it [keyword]:,FALSE,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,https://github.com/spring-projects/spring-data-jpa/commit/c13f3469e1d64ec97b11f0509e45f9c3fa8ff88a
1125062,"public static List<String> translateCommandline(String toProcess) {
    if (toProcess == null || toProcess.length() == 0) {
        return Collections.emptyList();
    }

    final int normal = 0;
    final int inQuote = 1;
    final int inDoubleQuote = 2;
    int state = normal;
    final StringTokenizer tok = new StringTokenizer(toProcess, ""\""\' "", true);
    final ArrayList<String> result = new ArrayList<>();
    final StringBuilder current = new StringBuilder();
    boolean lastTokenHasBeenQuoted = false;

    while (tok.hasMoreTokens()) {
        String nextTok = tok.nextToken();
        switch (state) {
            case inQuote:
                if (""\'"".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            case inDoubleQuote:
                if (""\"""".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            default:
                if (""\'"".equals(nextTok)) {
                    state = inQuote;
                } else if (""\"""".equals(nextTok)) {
                    state = inDoubleQuote;
                } else if ("" "".equals(nextTok)) {
                    if (lastTokenHasBeenQuoted || current.length() != 0) {
                        result.add(current.toString());
                        current.setLength(0);
                    }
                } else {
                    current.append(nextTok);
                }
                lastTokenHasBeenQuoted = false;
                break;
        }
    }

    if (lastTokenHasBeenQuoted || current.length() != 0) {
        result.add(current.toString());
    }

    if (state == inQuote || state == inDoubleQuote) {
        throw new IllegalArgumentException(""unbalanced quotes in "" + toProcess);
    }

    return result;
}

@Mojo(name = ""json"", defaultPhase = LifecyclePhase.GENERATE_RESOURCES)
public class JsonMojo extends AbstractFabric8Mojo {

    public static final String FABRIC8_PORT_HOST_PREFIX = ""docker.port.host."";
    public static final String FABRIC8_PORT_CONTAINER_PREFIX = ""docker.port.container."";
    public static final String FABRIC8_PORT_SERVICE = ""fabric8.service.port"";
    public static final String FABRIC8_CONTAINER_PORT_SERVICE = ""fabric8.service.containerPort"";
    public static final String FABRIC8_PROTOCOL_SERVICE = ""fabric8.service.protocol"";
    public static final String FABRIC8_PORT_SERVICE_PREFIX = FABRIC8_PORT_SERVICE + ""."";
    public static final String FABRIC8_CONTAINER_PORT_SERVICE_PREFIX = FABRIC8_CONTAINER_PORT_SERVICE + ""."";
    public static final String FABRIC8_PROTOCOL_SERVICE_PREFIX = FABRIC8_PROTOCOL_SERVICE + ""."";


    private static final String NAME = ""name"";
    private static final String ATTRIBUTE_TYPE = ""attributeType"";

    private static final String VOLUME_MOUNT_PATH = ""mountPath"";
    private static final String VOLUME_REGEX = ""fabric8.volume.(?<name>[^. ]*).(?<attributeType>[^. ]*)"";
    private static final Pattern VOLUME_PATTERN = Pattern.compile(VOLUME_REGEX);

    private static final String PARAM_REGEX = ""fabric8.parameter.(?<name>[^. ]*)(.)?(?<attributeType>[^ ]*)"";
    private static final Pattern PARAM_PATTERN = Pattern.compile(PARAM_REGEX);

    private static final String TEMPLATE_NAME = ""fabric8.template"";
    private static final String PARAMETER_PREFIX = ""fabric8.parameter"";
    private static final String PARAMETER_NAME_PREFIX = PARAMETER_PREFIX + "".%s"";
    private static final String PARAMETER_PROPERTY = PARAMETER_NAME_PREFIX + "".%s"";

    private static final String GENERATE = ""generate"";
    private static final String FROM = ""from"";
    private static final String VALUE = ""value"";
    private static final String DESCRIPTION = ""description"";

    @Component
    private MavenProjectHelper projectHelper;

    /**
     * The artifact type for attaching the generated kubernetes json file to the project
     */
    @Parameter(property = ""fabric8.kubernetes.artifactType"", defaultValue = ""json"")
    private String artifactType = ""json"";

    /**
     * The artifact classifier for attaching the generated kubernetes json file to the project
     */
    @Parameter(property = ""fabric8.kubernetes.artifactClassifier"", defaultValue = ""kubernetes"")
    private String artifactClassifier = ""kubernetes"";

    /**
     * Whether or not we should generate the Kubernetes JSON file using the MVEL template if there is not one specified
     * in the build (usually in src/main/resources/kubernetes.json)
     */
    @Parameter(property = ""fabric8.generateJson"", defaultValue = ""true"")
    private boolean generateJson;

    /**
     * Should we fail the build if no json files could be found
     */
    @Parameter(property = ""fabric8.failOnMissingJsonFiles"", defaultValue = ""true"")
    private boolean failOnMissingJsonFiles;

    /**
     * Whether we should include the namespace in the containers' env vars
     */
    @Parameter(property = ""fabric8.includeNamespaceEnvVar"", defaultValue = ""true"")
    private boolean includeNamespaceEnvVar;

    /**
     * The name of the env var to add that will contain the namespace at container runtime
     */
    @Parameter(property = ""fabric8.namespaceEnvVar"", defaultValue = ""KUBERNETES_NAMESPACE"")
    private String kubernetesNamespaceEnvVar;

    /**
     * The provider to include as a label. Set to empty to disable.
     */
    @Parameter(property = ""fabric8.provider"", defaultValue = ""fabric8"")
    private String provider;

    /**
     * The labels passed into the generated Kubernetes JSON template.
     * <p/>
     * If no value is explicitly configured in the maven plugin then we use all maven properties starting with ""fabric8.label.""
     */
    @Parameter()
    private Map<String, String> labels;

    /**
     * The environment variables passed into the generated Kubernetes JSON template.
     * <p/>
     * If no value is explicitly configured in the maven plugin then we use all maven properties starting with ""fabric8.env.""
     */
    @Parameter()
    private List<EnvVar> environmentVariables;

    /**
     * The container ports passed into the generated Kubernetes JSON template.
     */
    @Parameter()
    private List<ContainerPort> containerPorts;

    /**
     * Maps the port names to the default container port numbers
     */
    @Parameter()
    private Map<String, Integer> defaultContainerPortMap;

    /**
     * The service ports passed into the generated Kubernetes JSON template.
     */
    @Parameter()
    private List<ServicePort> servicePorts;

    /**
     * The ID prefix used in the generated Kubernetes JSON template
     */
    @Parameter(property = ""fabric8.replicas"", defaultValue = ""1"")
    private Integer replicaCount;

    /**
     * Should we wrap the generated ReplicationController objects in a DeploymentConfig
     */
    // TODO lets disable by default until its working :)
    @Parameter(property = ""fabric8.useDeploymentConfig"", defaultValue = ""false"")
    private boolean useDeploymentConfig;

    /**
     * The last triggered image tag if generating a DeploymentConfig
     */
    @Parameter(property = ""fabric8.lastTriggeredImageTag"", defaultValue = ""latest"")
    private String lastTriggeredImageTag;

    /**
     * The strategy name for the DeploymentConfig
     */
    @Parameter(property = ""fabric8.deploymentStrategy"", defaultValue = ""Recreate"")
    private String deploymentStrategy;

    /**
     * The extra additional kubernetes JSON file for things like services
     */
    @Parameter(property = ""fabric8.extra.json"", defaultValue = ""${basedir}/target/classes/kubernetes-extra.json"")
    private File kubernetesExtraJson;

/**
     * Temporary directory used for creating the template annotations
     */
    @Parameter(property = ""fabric8.templateTempDir"", defaultValue = ""${basedir}/target/fabric8/template-workdir"")
    private File templateTempDir;

    /**
     * The URL to use to link to the icon in the generated Template.
     * <p/>
     * For using a common set of icons, see the {@link #iconRef} option.
     */
    @Parameter(property = ""fabric8.iconUrl"")
    private String iconUrl;

    /**
     * The URL prefix added to the relative path of the icon file
     */
    @Parameter(property = ""fabric8.iconUrlPrefix"")
    private String iconUrlPrefix;

    /**
     * The SCM branch used when creating a URL to the icon file
     */
    @Parameter(property = ""fabric8.iconBranch"", defaultValue = ""master"")
    private String iconBranch;

    /**
     * The replication controller name used in the generated Kubernetes JSON template
     */
    @Parameter(property = ""fabric8.replicationController.name"", defaultValue = ""${project.artifactId}"")
    private String replicationControllerName;

    /**
     * The name label used in the generated Kubernetes JSON template
     */
    @Parameter(property = ""fabric8.kubernetes.name"", defaultValue = ""${project.artifactId}"")
    private String kubernetesName;

    /**
     * The name label used in the generated Kubernetes JSON template
     */
    @Parameter(property = ""fabric8.container.name"", defaultValue = ""${project.artifactId}"")
    private String kubernetesContainerName;

    /**
     * The service name
     */
    @Parameter(property = ""fabric8.service.name"", defaultValue = ""${project.artifactId}"")
    private String serviceName;

    /**
     * Should we generate headless services (services with no ports)
     */
    // TODO for now lets default to not creating headless services as it barfs when used with kubernetes...
    //@Parameter(property = ""fabric8.service.headless"", defaultValue = ""true"")
    @Parameter(property = ""fabric8.service.headless"", defaultValue = ""false"")
    private boolean headlessServices;

    /**
     * The service port
     */
    @Parameter(property = FABRIC8_PORT_SERVICE)
    private Integer servicePort;

    /**
     * The service container port
     */
    @Parameter(property = FABRIC8_CONTAINER_PORT_SERVICE)
    private String serviceContainerPort;

    /**
     * The service protocol
     */
    @Parameter(property = FABRIC8_PROTOCOL_SERVICE, defaultValue = ""TCP"")
    private String serviceProtocol;

    /**
     * The docker image pull policy for non-snapshots
     */
    @Parameter(property = ""fabric8.imagePullPolicy"")
    private String imagePullPolicy;

    /**
     * The docker image pull policy for snapshot releases (which should pull always)
     */
    @Parameter(property = ""fabric8.imagePullPolicySnapshot"")
    private String imagePullPolicySnapshot;

    /**
     * Whether the plugin should discover all the environment variable json schema files in the classpath and export those into the generated kubernetes JSON
     */
    @Parameter(property = ""fabric8.includeAllEnvironmentVariables"", defaultValue = ""true"")
    private boolean includeAllEnvironmentVariables;

    @Parameter(property = ""fabric8.containerPrivileged"")
    protected Boolean containerPrivileged;

    @Parameter(property = ""fabric8.serviceAccount"")
    protected String serviceAccount;

    /**
     * The properties file used to specify the OpenShift Template parameter values and descriptions. The properties file should be of the form
     * <code>
     *     <pre>
     *         FOO.value = ABC
     *         FOO.description = this is the description of FOO
     *     </pre>
     * </code>
     */
    @Parameter(property = ""fabric8.templateParametersFile"", defaultValue = ""${basedir}/src/main/fabric8/templateParameters.properties"")
    protected File templateParametersPropertiesFile;

    /**
     * Defines the maximum size in kilobytes that the data encoded URL of the icon should be before we defer
     * and try to use an external URL
     */
    @Parameter(property = ""fabric8.maximumDataUrlSizeK"", defaultValue = ""2"")
    private int maximumDataUrlSizeK;

    @Component
    protected ArtifactResolver resolver;

    @Parameter(property = ""localRepository"", readonly = true, required = true)
    protected ArtifactRepository localRepository;

    @Parameter(property = ""project.remoteArtifactRepositories"")
    protected List remoteRepositories;
}",Replace Temp with Query,"Replace the temp expression ""lastTokenHasBeenQuoted || current.length() != 0"" with a query method and name it [keyword]:",FALSE,fabric8-maven-plugin/src/main/java/io/fabric8/maven/support/Commandline.java,https://github.com/fabric8io/fabric8/commit/e068eb7f484f24dee285d29b8a910d9019592020
1123684,"public class TestableWithTypeCode {

    public static final int AMERICAN_FLAG = 0;
    public static final int BUBBLE = 1;
    public static final int COUNTING = 2;

    private int typeCode;
    private String input;

    public TestableWithTypeCode(int typeCode) {
        this.typeCode = typeCode;
    }

    public String getInput() {
        return input;
    }

    public String getName() {
        switch (typeCode) {
            case AMERICAN_FLAG: return ""AmericanFlag sort"";
            case BUBBLE: return ""Bubble sort"";
            case COUNTING: return ""Counting sort"";
            default: throw new IllegalArgumentException(""Unknown type code"");
        }
    }

    public Integer[] sort(Integer[] input) {
        switch (typeCode) {
            case AMERICAN_FLAG:
                return AmericanFlagSort.sort(input);
            case BUBBLE:
                return BubbleSort.sort(input);
            case COUNTING:
                return CountingSort.sort(input);
            default:
                throw new IllegalArgumentException(""Unknown type code"");
        }
    }
}

public class SortsTiming {

    private static final DecimalFormat FORMAT = new DecimalFormat(""#.###"");
    private static final int SIZE = 1024*100;
    private static final boolean showResult = false;
    private static final boolean checkResults = true;

    private static int insertionCount = 0;
    private static double[] insertionResults = null;
    private static int bubbleCount = 0;
    private static double[] bubbleResults = null;
    private static int shellCount = 0;
    private static double[] shellResults = null;
    private static int mergeCount = 0;
    private static double[] mergeResults = null;
    private static int quickCount = 0;
    private static double[] quickResults = null;
    private static int heapCount = 0;
    private static double[] heapResults = null;
    private static int countingCount = 0;
    private static double[] countingResults = null;
    private static int radixCount = 0;
    private static double[] radixResults = null;
    private static int americanFlagCount = 0;
    private static double[] americanFlagResults = null;

    private static Integer[] unsorted = null;
    private static Integer[] sorted = null;
    private static Integer[] reverse = null;

    public static void main(String[] args) {
        System.out.println(""Generating random array."");
        Random random = new Random();
        unsorted = new Integer[SIZE];
        int i = 0;
        while (i < unsorted.length) {
            int j = random.nextInt(unsorted.length * 10);
            unsorted[i++] = j;
        }
        System.out.println(""Generated random array."");

        System.out.println(""Generating sorted array."");
        sorted = new Integer[SIZE];
        for (i = 0; i < sorted.length; i++) {
            sorted[i] = i;
        }
        System.out.println(""Generated sorted array."");

        System.out.println(""Generating reverse sorted array."");
        reverse = new Integer[SIZE];
        for (i = (reverse.length - 1); i >= 0; i--) {
            reverse[i] = (SIZE - 1) - i;
        }
        System.out.println(""Generated reverse sorted array."");
        System.out.println();
        System.out.flush();

        System.out.println(""Starting sorts..."");
        System.out.println();
        System.out.flush();

        insertionResults = new double[1 * 3];
        insertionCount = runTest(new Insertion(), unsorted, sorted, insertionResults, insertionCount);
        showComparison();

        bubbleResults = new double[1 * 3];
        bubbleCount = runTest(new Bubble(), unsorted, sorted, bubbleResults, bubbleCount);
        showComparison();

        shellResults = new double[1 * 3];
        shellCount = runTest(new Shell(), unsorted, sorted, shellResults, shellCount);
        showComparison();

        mergeResults = new double[2 * 3];
        mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);
        mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);
        showComparison();

        quickResults = new double[3 * 3];
        quickCount = runTest(new QuickFirst(), unsorted, sorted, quickResults, quickCount);
        quickCount = runTest(new QuickMiddle(), unsorted, sorted, quickResults, quickCount);
        quickCount = runTest(new QuickRandom(), unsorted, sorted, quickResults, quickCount);
        showComparison();

        heapResults = new double[1 * 3];
        heapCount = runTest(new Heap(), unsorted, sorted, heapResults, heapCount);
        showComparison();

        countingResults = new double[1 * 3];
        countingCount = runTest(new Counting(), unsorted, sorted, countingResults, countingCount);
        showComparison();

        radixResults = new double[1 * 3];
        radixCount = runTest(new Radix(), unsorted, sorted, radixResults, radixCount);
        showComparison();

        americanFlagResults = new double[1 * 3];
        americanFlagCount = runTest(new AmericanFlag(), unsorted, sorted, americanFlagResults, americanFlagCount);
        showComparison();
    }

    private static final int runTest(Testable testable, Integer[] unsorted, Integer[] sorted, double[] results, int count) {
        long bInsertion = System.nanoTime();
        Integer[] result = testable.sort(unsorted.clone());
        if (checkResults && !check(result))
            System.err.println(testable.getName()+"" failed."");
        long aInsertion = System.nanoTime();
        double diff = (aInsertion - bInsertion) / 1000000d / 1000d;
        System.out.println(""Random: ""+testable.getName()+""="" + FORMAT.format(diff) + "" secs"");
        if (showResult)
            showResult(unsorted, result);
        results[count++] = diff;
        putOutTheGarbage();

        bInsertion = System.nanoTime();
        result = InsertionSort.sort(sorted.clone());
        if (checkResults && !check(result))
            System.err.println(testable.getName()+"" failed."");
        aInsertion = System.nanoTime();
        diff = (aInsertion - bInsertion) / 1000000d / 1000d;
        System.out.println(""Sorted: ""+testable.getName()+""="" + FORMAT.format(diff) + "" secs"");
        if (showResult)
            showResult(sorted, result);
        results[count++] = diff;
        putOutTheGarbage();

        bInsertion = System.nanoTime();
        result = InsertionSort.sort(reverse.clone());
        if (checkResults && !check(result))
            System.err.println(testable.getName()+""InsertionSort."");
        aInsertion = System.nanoTime();
        diff = (aInsertion - bInsertion) / 1000000d / 1000d;
        System.out.println(""Reverse sorted: ""+testable.getName()+""="" + FORMAT.format(diff) + "" secs"");
        if (showResult)
            showResult(reverse, result);
        results[count++] = diff;
        putOutTheGarbage();

        System.out.println();
        System.out.flush();

        return count;
    }

    public static abstract class Testable {
        String input = null;
        public String getInput() {
            return input;
        }
        public abstract String getName();
        public abstract Integer[] sort(Integer[] input);
    }

    private static class AmericanFlag extends Testable {
        @Override
        public String getName() {
            return ""AmericanFlag sort"";
        }

        @Override
        public Integer[] sort(Integer[] input) {
            return AmericanFlagSort.sort(input);
        }
    }
}",Replace Type Code with Subclasses,Replace the type code with subclasses and name them [keyword]:,FALSE,src/com/jwetherell/algorithms/sorts/timing/SortsTiming.java,https://github.com/phishman3579/java-algorithms-implementation/commit/ab98bcacf6e5bf1c3a06f6bcca68f178f880ffc9
1120931,"private void downloadArtifact(
    final Artifact artifactToDownload,
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Map<Path, SortedSet<Prebuilt>> buckFiles,
    MutableDirectedGraph<Artifact> graph)
    throws IOException, ArtifactResolutionException {

    String projectName = getProjectName(artifactToDownload);
    Path project = buckRepoRoot.resolve(buckThirdPartyRelativePath).resolve(projectName);
    Files.createDirectories(project);

    SortedSet<Prebuilt> libs = buckFiles.get(project);
    if (libs == null) {
        libs = new TreeSet<>();
        buckFiles.put(project, libs);
    }

    Prebuilt library = resolveLib(artifactToDownload, repoSys, session, project);
    libs.add(library);

    Iterable<Artifact> incoming = graph.getIncomingNodesFor(artifactToDownload);
    Iterable<Artifact> outgoing = graph.getOutgoingNodesFor(artifactToDownload);

    for (Artifact artifact : incoming) {
        String groupName = getProjectName(artifact);
        if (projectName.equals(groupName)) {
            library.addDep(String.format("":%s"", artifact.getArtifactId()));
        } else {
            library.addDep(buckThirdPartyRelativePath, artifact);
        }
    }

    for (Artifact artifact : outgoing) {
        String groupName = getProjectName(artifact);
        if (!groupName.equals(projectName)) {
            library.addVisibility(buckThirdPartyRelativePath, artifact);
        }
    }
}

private Prebuilt resolveLib(
    Artifact artifact,
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Path project) throws ArtifactResolutionException, IOException {
Artifact jar = new DefaultArtifact(
    artifact.getGroupId(),
    artifact.getArtifactId(),
    ""jar"",
    artifact.getVersion());

Path relativePath = resolveArtifact(jar, repoSys, session, project);

Prebuilt library = new Prebuilt(jar.getArtifactId(), relativePath);

downloadSources(jar, repoSys, session, project, library);
return library;
}

/**
 * @return {@link Path} to the file
 */
private Path resolveArtifact(
    Artifact artifact,
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Path project)
    throws ArtifactResolutionException, IOException {
ArtifactResult result = repoSys.resolveArtifact(
    session,
    new ArtifactRequest(artifact, repos, null));
return copy(result, project);
}

private void downloadSources(
    Artifact artifact,
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Path project,
    Prebuilt library) throws IOException {
Artifact srcs = new SubArtifact(artifact, ""sources"", ""jar"");
try {
    Path relativePath = resolveArtifact(srcs, repoSys, session, project);
    library.setSourceJar(relativePath);
} catch (ArtifactResolutionException e) {
    System.err.println(""Skipping sources for: "" + srcs);
}
}

/**
 *  com.example:foo:1.0 -> ""example""
 */
private static String getProjectName(Artifact artifact) {
int index = artifact.getGroupId().lastIndexOf('.');
String projectName = artifact.getGroupId();
if (index != -1) {
    projectName = projectName.substring(index + 1);
}
return projectName;
}

private void createBuckFiles(Map<Path, SortedSet<Prebuilt>> buckFilesData) throws IOException {
URL templateUrl = Resources.getResource(TEMPLATE);
String template = Resources.toString(templateUrl, UTF_8);
STGroupString groups = new STGroupString(""prebuilt-template"", template);

for (Map.Entry<Path, SortedSet<Prebuilt>> entry : buckFilesData.entrySet()) {
    Path buckFile = entry.getKey().resolve(""BUCK"");
    if (Files.exists(buckFile)) {
    Files.delete(buckFile);
    }

    ST st = Preconditions.checkNotNull(groups.getInstanceOf(""/prebuilts""));
    st.add(""data"", entry.getValue());
    Files.write(buckFile, st.render().getBytes(UTF_8));
}
}

private Path copy(ArtifactResult result, Path destDir) throws IOException {
Path source = result.getArtifact().getFile().toPath();
Path sink = destDir.resolve(source.getFileName());

if (!Files.exists(sink)) {
    Files.copy(source, sink);
}

return sink.getFileName();
}

private  MutableDirectedGraph<Artifact> buildDependencyGraph(
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Map<String, Artifact> knownDeps) throws ArtifactDescriptorException {
MutableDirectedGraph<Artifact> graph;
graph = new MutableDirectedGraph<>();
for (Artifact dep : knownDeps.values()) {
    String key = buildKey(dep);

    Preconditions.checkNotNull(knownDeps.get(key));

    graph.addNode(dep);

    List<Dependency> dependencies = getDependenciesOf(repoSys, session, dep);

    for (Dependency dependency : dependencies) {
    if (dependency.getArtifact() == null) {
        System.out.println(""Skipping because artifact missing: "" + dependency);
        continue;
    }

    String depKey = buildKey(dependency.getArtifact());
    Artifact actualDep = knownDeps.get(depKey);
    if (actualDep == null) {
        continue;
    }
    // It's possible that the runtime dep of an artifact is the test time dep of another.
    if (isTestTime(dependency)) {
        continue;
    }

    // TODO(simons): Do we always want optional dependencies?
//        if (dependency.isOptional()) {
//          continue;
//        }

    Preconditions.checkNotNull(actualDep, key + "" -> "" + dep + "" in "" + knownDeps.keySet());
    graph.addNode(actualDep);
    graph.addEdge(actualDep, dep);
    }
}
return graph;
}

private List<Dependency> getDependenciesOf(
    RepositorySystem repoSys,
    RepositorySystemSession session,
    Artifact dep) throws ArtifactDescriptorException {
ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
descriptorRequest.setArtifact(dep);
descriptorRequest.setRepositories(repos);
descriptorRequest.setRequestContext(JavaScopes.RUNTIME);

ArtifactDescriptorResult result = repoSys.readArtifactDescriptor(session, descriptorRequest);
return result.getDependencies();
}

private boolean isTestTime(Dependency dependency) {
return TEST.equals(dependency.getScope());
}

private ImmutableMap<String, Artifact> getRunTimeTransitiveDeps(
    RepositorySystem repoSys,
    RepositorySystemSession session,
    String... mavenCoords)
    throws RepositoryException {

CollectRequest collectRequest = new CollectRequest();
collectRequest.setRequestContext(JavaScopes.RUNTIME);
collectRequest.setRepositories(repos);

for (String coord : mavenCoords) {
    DefaultArtifact artifact = new DefaultArtifact(coord);
    collectRequest.addDependency(new Dependency(artifact, JavaScopes.RUNTIME));

    ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
    descriptorRequest.setArtifact(artifact);
    // Setting this appears to have exactly zero effect on the returned values. *sigh*
//      descriptorRequest.setRequestContext(JavaScopes.RUNTIME);
    descriptorRequest.setRepositories(repos);
    ArtifactDescriptorResult descriptorResult = repoSys.readArtifactDescriptor(
        session,
        descriptorRequest);

    for (Dependency dependency : descriptorResult.getDependencies()) {
    if (isTestTime(dependency)) {
        continue;
    }
    collectRequest.addDependency(dependency);
    }
    for (Dependency dependency : descriptorResult.getManagedDependencies()) {
    if (isTestTime(dependency)) {
        continue;
    }
    collectRequest.addManagedDependency(dependency);
    }
}

DependencyFilter filter = DependencyFilterUtils.classpathFilter(JavaScopes.RUNTIME);
DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, filter);

DependencyResult dependencyResult = repoSys.resolveDependencies(session, dependencyRequest);

ImmutableSortedMap.Builder<String, Artifact> knownDeps = ImmutableSortedMap.naturalOrder();
for (ArtifactResult artifactResult : dependencyResult.getArtifactResults()) {
    Artifact node = artifactResult.getArtifact();
    knownDeps.put(buildKey(node), node);
}
return knownDeps.build();
}
",Separate Query from Modifier,Separate the query from downloadArtifact into a separate method and name it [keyword]:,FALSE,src/com/facebook/buck/maven/Resolver.java,https://github.com/facebook/buck/commit/7e104c3ed4b80ec8e9b72356396f879d1067cc40
1120903,"InetAddress[] addresses = InetAddress.getAllByName(mHost);
SocketAddress socketAddress = null;
for (int i = 0; i < addresses.length; i++) {
    try {
        socketAddress = new InetSocketAddress(addresses[i], mPort);
        if (mConnectionSecurity == ConnectionSecurity.SSL_TLS_REQUIRED) {
            mSocket = mTrustedSocketFactory.createSocket(null, mHost, mPort, mClientCertificateAlias);
            mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
        } else {
            mSocket = new Socket();
            mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
        }
    } catch (SocketException e) {
        if (i < (addresses.length - 1)) {
            continue;
        }
        throw new MessagingException(""Cannot connect to host"", e);
    }
    break;
}

// Set socket timeout
mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);

// Get input/output streams and read server banner
mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(), 1024));
mOut = new BufferedOutputStream(mSocket.getOutputStream(), 1024);
executeSimpleCommand(null);

// Query local address
InetAddress localAddress = mSocket.getLocalAddress();
String localHost = localAddress.getCanonicalHostName();
String ipAddr = localAddress.getHostAddress();
boolean invalidLocalHost = localHost.equals("""") || localHost.equals(ipAddr) || localHost.contains(""_"");
if (invalidLocalHost) {
    if (!ipAddr.equals("""")) {
        if (localAddress instanceof Inet6Address) {
            localHost = ""[IPv6:"" + ipAddr + ""]"";
        } else {
            localHost = ""["" + ipAddr + ""]"";
        }
    } else {
        localHost = ""android"";
    }
}

// Query server extensions
Map<String, String> extensions = sendHello(localHost);
m8bitEncodingAllowed = extensions.containsKey(""8BITMIME"");


private Map<String,String> sendHello(String host) throws IOException, MessagingException {
    Map<String, String> extensions = new HashMap<String, String>();
    try {
        List<String> results = executeSimpleCommand(""EHLO "" + host);
        // Remove the EHLO greeting response
        results.remove(0);
        for (String result : results) {
            String[] pair = result.split("" "", 2);
            extensions.put(pair[0].toUpperCase(Locale.US), pair.length == 1 ? """" : pair[1]);
        }
    } catch (NegativeSmtpReplyException e) {
        if (K9MailLib.isDebug()) {
            Log.v(LOG_TAG, ""Server doesn't support the EHLO command. Trying HELO..."");
        }

        try {
            executeSimpleCommand(""HELO "" + host);
        } catch (NegativeSmtpReplyException e2) {
            Log.w(LOG_TAG, ""Server doesn't support the HELO command. Continuing anyway."");
        }
    }
    return extensions;
}

@Override
public void sendMessage(Message message) throws MessagingException {
    List<Address> addresses = new ArrayList<Address>();
    {
        addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.TO)));
        addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.CC)));
        addresses.addAll(Arrays.asList(message.getRecipients(RecipientType.BCC)));
    }
    message.setRecipients(RecipientType.BCC, null);

    Map<String, List<String>> charsetAddressesMap =
        new HashMap<String, List<String>>();
    for (Address address : addresses) {
        String addressString = address.getAddress();
        String charset = CharsetSupport.getCharsetFromAddress(addressString);
        List<String> addressesOfCharset = charsetAddressesMap.get(charset);
        if (addressesOfCharset == null) {
            addressesOfCharset = new ArrayList<String>();
            charsetAddressesMap.put(charset, addressesOfCharset);
        }
        addressesOfCharset.add(addressString);
    }

    for (Map.Entry<String, List<String>> charsetAddressesMapEntry :
            charsetAddressesMap.entrySet()) {
        String charset = charsetAddressesMapEntry.getKey();
        List<String> addressesOfCharset = charsetAddressesMapEntry.getValue();
        message.setCharset(charset);
        sendMessageTo(addressesOfCharset, message);
    }
}

private void sendMessageTo(List<String> addresses, Message message)
throws MessagingException {

    close();
    open();

    if (!m8bitEncodingAllowed) {
        message.setUsing7bitTransport();
    }
    // If the message has attachments and our server has told us about a limit on
    // the size of messages, count the message's size before sending it
    if (mLargestAcceptableMessage > 0 && message.hasAttachments()) {
        if (message.calculateSize() > mLargestAcceptableMessage) {
            throw new MessagingException(""Message too large for server"", true);
        }
    }

    boolean entireMessageSent = false;
    Address[] from = message.getFrom();
    try {
        executeSimpleCommand(""MAIL FROM:"" + ""<"" + from[0].getAddress() + "">""
                + (m8bitEncodingAllowed ? "" BODY=8BITMIME"" : """"));
        for (String address : addresses) {
            executeSimpleCommand(""RCPT TO:"" + ""<"" + address + "">"");
        }
        executeSimpleCommand(""DATA"");

        EOLConvertingOutputStream msgOut = new EOLConvertingOutputStream(
                new LineWrapOutputStream(new SmtpDataStuffing(mOut), 1000));

        message.writeTo(msgOut);

        // We use BufferedOutputStream. So make sure to call flush() !
        msgOut.flush();

        entireMessageSent = true; // After the ""\r\n."" is attempted, we may have sent the message
        executeSimpleCommand(""\r\n."");
    } catch (NegativeSmtpReplyException e) {
        throw e;
    } catch (Exception e) {
        MessagingException me = new MessagingException(""Unable to send message"", e);
        me.setPermanentFailure(entireMessageSent);

        throw me;
    } finally {
        close();
    }

}

@Override
public void close() {
    try {
        executeSimpleCommand(""QUIT"");
    } catch (Exception e) {

    }
    try {
        mIn.close();
    } catch (Exception e) {

    }
    try {
        mOut.close();
    } catch (Exception e) {

    }
    try {
        mSocket.close();
    } catch (Exception e) {

    }
    mIn = null;
    mOut = null;
    mSocket = null;
}

private String readLine() throws IOException {
    StringBuilder sb = new StringBuilder();
    int d;
    while ((d = mIn.read()) != -1) {
        if (((char)d) == '\r') {
            continue;
        } else if (((char)d) == '\n') {
            break;
        } else {
            sb.append((char)d);
        }
    }
    String ret = sb.toString();
    if (K9MailLib.isDebug() && DEBUG_PROTOCOL_SMTP)
        Log.d(LOG_TAG, ""SMTP <<< "" + ret);

    return ret;
}",Split Phase,Refactor the socket connection and server greeting logic into two separate phases and name them [keyword]A and [keyword]B:,FALSE,k9mail-library/src/main/java/com/fsck/k9/mail/transport/SmtpTransport.java,https://github.com/k9mail/k-9/commit/9d44f0e06232661259681d64002dd53c7c43099d
1120803,"public class AlterUser extends DefineCommand {
    @Override
    public int update() {
        session.commit(true);
        Database db = session.getDatabase();
        User tempUser = session.getUser();
        boolean tempFlag = user != tempUser;

        switch (type) {
            case CommandInterface.ALTER_USER_SET_PASSWORD:
                if (tempFlag) {
                    tempUser.checkAdmin();
                }
                tempFlag = (hash != null && salt != null);
                if (tempFlag) {
                    CreateUser.setSaltAndHash(user, session, salt, hash);
                } else {
                    CreateUser.setPassword(user, session, password);
                }
                break;

            case CommandInterface.ALTER_USER_RENAME:
                tempUser.checkAdmin();
                tempFlag = (db.findUser(newName) != null || newName.equals(user.getName()));
                if (tempFlag) {
                    throw DbException.get(ErrorCode.USER_ALREADY_EXISTS_1, newName);
                }
                db.renameDatabaseObject(session, user, newName);
                break;

            case CommandInterface.ALTER_USER_ADMIN:
                tempUser.checkAdmin();
                tempFlag = !admin;
                if (tempFlag) {
                    user.checkOwnsNoSchemas();
                }
                user.setAdmin(admin);
                break;

            default:
                DbException.throwInternalError(""type="" + type);
        }

        db.update(session, user);
        return 0;
    }
}

public class CreateUser extends DefineCommand {

    private String userName;
    private boolean admin;
    private Expression password;
    private Expression salt;
    private Expression hash;
    private boolean ifNotExists;
    private String comment;

    public CreateUser(Session session) {
        super(session);
    }

    public void setIfNotExists(boolean ifNotExists) {
        this.ifNotExists = ifNotExists;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public void setPassword(Expression password) {
        this.password = password;
    }

    static void setSaltAndHash(User user, Session session, Expression salt, Expression hash) {
        user.setSaltAndHash(getByteArray(session, salt), getByteArray(session, hash));
    }

    private static byte[] getByteArray(Session session, Expression e) {
        String s = e.optimize(session).getValue(session).getString();
        return s == null ? new byte[0] : StringUtils.convertHexToBytes(s);
    }

    static void setPassword(User user, Session session, Expression password) {
        String pwd = password.optimize(session).getValue(session).getString();
        char[] passwordChars = pwd == null ? new char[0] : pwd.toCharArray();
        byte[] userPasswordHash;
        String userName = user.getName();
        if (userName.length() == 0 && passwordChars.length == 0) {
            userPasswordHash = new byte[0];
        } else {
            userPasswordHash = SHA256.getKeyPasswordHash(userName, passwordChars);
        }
        user.setUserPasswordHash(userPasswordHash);
    }

    @Override
    public int update() {
        session.getUser().checkAdmin();
        session.commit(true);
        Database db = session.getDatabase();
        if (db.findRole(userName) != null) {
            throw DbException.get(ErrorCode.ROLE_ALREADY_EXISTS_1, userName);
        }
        if (db.findUser(userName) != null) {
            if (ifNotExists) {
                return 0;
            }
            throw DbException.get(ErrorCode.USER_ALREADY_EXISTS_1, userName);
        }
        int id = getObjectId();
        User user = new User(db, id, userName, false);
        user.setAdmin(admin);
        user.setComment(comment);
        if (hash != null && salt != null) {
            setSaltAndHash(user, session, salt, hash);
        } else if (password != null) {
            setPassword(user, session, password);
        } else {
            throw DbException.throwInternalError();
        }
        db.addDatabaseObject(session, user);
        return 0;
    }

    public void setSalt(Expression e) {
        salt = e;
    }

    public void setHash(Expression e) {
        hash = e;
    }

    public void setAdmin(boolean b) {
        admin = b;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    @Override
    public int getType() {
        return CommandInterface.CREATE_USER;
    }

}",Split Variable,"Split the reused variable ""tempFlag"" into separate variables, and name them [keyword]A, [keyword]B, etc:",FALSE,lealone-sql/src/main/java/org/lealone/command/ddl/AlterUser.java,https://github.com/codefollower/Lealone/commit/7a2e0ae5f6172cbe34f9bc4a5cde666314ff75dd